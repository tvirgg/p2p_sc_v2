# Исправления в P2P контракте

## Выявленные проблемы

1. **Счетчик сделок (`dealCounter`) не увеличивается** - остается 0 вместо 1 после создания сделки
2. **Сумма сделки (`amount`) не сохраняется** - возвращается "0" вместо "2000000000"

## Внесенные исправления

1. **Улучшена функция `load_data`**:
   - Изменен способ проверки наличия данных в слайсе с `ds.slice_bits() > 0` на `~ ds.slice_empty?()`
   - Добавлены комментарии для лучшего понимания кода
   - Улучшена структура функции для более надежной загрузки данных

2. **Исправлен способ инкрементации счетчика сделок**:
   - В функции `recv_external` изменен способ инкрементации с `dc += 1` на `dc = dc + 1`
   - Это соответствует исправлению, которое уже было применено в функции `recv_internal`

3. **Добавлены отладочные функции**:
   - `debug_deal_exists` - проверяет существование сделки по ID
   - `debug_get_raw_data` - возвращает сырые данные контракта
   - Эти функции помогают диагностировать проблемы с хранением данных

4. **Обновлены тесты**:
   - Добавлена проверка существования сделки после её создания
   - Добавлена обработка ошибок при получении информации о сделке
   - Улучшена диагностика при выполнении тестов

## Технические детали исправлений

### Функция `load_data`

Изменен способ проверки наличия данных в слайсе:

На данном этапе нас интересуют папки contracts и wrappers, в которых мы будем писать код на FunС и обёртку для него на TypeScript соответственно.

Что такое FunC?
Для программирования смарт-контрактов в блокчейне TON рекомендуется использовать язык FunC. Подробнее с ним можно ознакомиться в документации

Подготовим файл для нашего кода
Зайдём в папку contracts:

cd contracts
И откроем файл counter.fc. На своем экране вы увидите смарт-контракт с всего одной пустой функцией. Теперь мы готовы начать писать наш первый смарт-контракт.

Функции смарт-контракта
У смарт-контрактов в сети TON есть две основных функции:

Первая — recv_external(), эта функция выполняется, когда запрос к контракту происходит из внешнего мира, то есть не из TON. Например, когда вы из приложения обращаетесь к смарт-контракту кошелька, чтобы перевести другу Toncoin, это обращение происходит как раз через recv_external().
Вторая — recv_internal(), эта функция выполняется, когда обращение к контракту происходит непосредственно внутри блокчейна. Например, когда какой-либо контракт обращается к нашему.
Под наши условия подходит recv_internal()

В файле counter.fc уже есть объявленная функция без кода:

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    ;; здесь будет код
}
;; две точки с запятой — синтаксис однострочного комментария

Функция принимает числа с балансом контракта, суммой входящего сообщения, ячейкой с исходным сообщением и слайс in_msg_body, в котором хранится только тело принимаемого сообщения. Также мы используем ключевое слово impure.

impure — ключевое слово, которое указывает компилятору на то, что нельзя вырезать её выполнение при оптимизациях.

Например, мы должны указать спецификатор impure, если функция может изменять хранилище контрактов, отправлять сообщения или генерировать исключения.

Важно: Если не указано impure и результат вызова функции не используется, то компилятор FunC может свободно удалить этот вызов функции.

А вот чтобы понять, что такое слайс и ячейка, поговорим про типы данных в TON.

Типы cell, slice, builder, integer в FunC
В нашем простом смарт-контракте мы будем использовать всего лишь четыре типа:

Cell - ячейка TVM, состоящая из 1023 бит данных и до 4 ссылок на другие ячейки. Наличие ссылок формирует так называемое "дерево ячеек".
Slice - частичное представление ячейки TVM, используемой для прочтения данных из ячейки.
Builder - частично построенная ячейка, содержащая до 1023 бит данных и до четырех ссылок. В такой тип ячейки мы можем только записывать новые данные, чтобы потом перевести её в обычный Cell.
Integer - знаковое 257-битное целое число.
Подробнее о типах в FunC можно почитать в документации.

Говоря простым языком, cell - это запечатанная ячейка, slice - это ячейка, из которой можно читать данные, а builder - это ячейка, в которую можно писать данные.

Читаем Integer из тела сообщения
Чтобы прочитать из полученного слайса с телом сообщения Integer, добавим следуюший код: int n = in_msg_body~load_uint(32);

Функция recv_internal() теперь выглядит так:

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    int n = in_msg_body~load_uint(32);
}
load_uint — функция из стандартной библиотеки FunC, она читает и возвращает целое беззнаковое число с заданным размером из слайса.

Данные смарт-контракта
Чтобы добавить полученную переменную к total и сохранить значение в смарт-контракте, рассмотрим, как реализована функциональность хранения постоянных данных/хранилища в TON.

Примечание: не путайте с TON Storage, хранилище в предыдущем предложении — удобная аналогия.

Виртуальная машина TVM является стековой, но помимо стека, в ней присутствуют специальные "регистры", которые хранят, например, код смарт-контракта, глобальный конфиг блокчейна, а также данные смарт-контракта.

Для хранения постоянных данных отведен регистр с4 с типом Cell.

Подробнее с регистрами можно ознакомиться в документации.

Возьмем данные из с4
Для того, чтобы "достать" данные из с4, нам понадобятся две функции из стандартной библиотеки FunC.

А именно: get_data - берет ячейку из регистра c4. begin_parse - ячейку преобразует в slice.

Создадим переменную ds, в которую и положим полученный слайс.

slice ds = get_data().begin_parse();

А также прочитаем из этого слайса в числовую переменную total число размером 64 бит для суммирования в соответствии с нашей задачей (с помощью уже знакомой нам функции load_uint).

int total = ds~load_uint(64);

Теперь наша функция будет выглядеть так:

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    int n = in_msg_body~load_uint(32);

    slice ds = get_data().begin_parse();
    int total = ds~load_uint(64);
}
Cуммируем
Для суммирования будем использовать операцию суммирования +, а также присвоение =.

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    int n = in_msg_body~load_uint(32);

    slice ds = get_data().begin_parse();
    int total = ds~load_uint(64);

    total += n;
}
Как и во многих других языках программирования, в FunC можно объединить операции + и = в +=. То же самое и для -=, /=, *=.

Cохраняем значение
Для того, чтобы сохранить значение total в постоянные данные контракта, нам необходимо выполнить четыре действия:

Создать Builder для будущей ячейки данных
Записать в этот билдер значение
Преобразовать билдер в ячейку
Записать полученную ячейку в регистр c4
Делать это мы будем опять же с помощью функций стандартной библиотеки FunC.

set_data(begin_cell().store_uint(total, 64).end_cell());

begin_cell() - создаст Builder для будущей ячейки store_uint()- запишет значение total end_cell()- создать Cell из билдера set_data() - запишет ячейку в регистр с4

Итог:

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    int n = in_msg_body~load_uint(32);

    slice ds = get_data().begin_parse();
    int total = ds~load_uint(64);

    total += n;

    set_data(begin_cell().store_uint(total, 64).end_cell());
}
Генерация исключений
Все, что осталось сделать в нашей функции recv_internal() — это добавить вызов исключения, если в теле полученного сообщения недостаточно бит для 32-битного числа.

Для этого будем использовать встроенные исключения.

Исключения могут быть вызваны условными примитивами throw_if и throw_unless, а также безусловным throw.

Воспользуемся throw_if и передадим любой код ошибки. Для того, чтобы взять битность, используем slice_bits().

throw_if(35,in_msg_body.slice_bits() < 32);
Кстати, в TVM (виртуальная машина TON) есть стандартные коды исключений, они нам очень понадобятся в тестах. Посмотреть можно здесь.

Вставим в начало функции:

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    throw_if(35,in_msg_body.slice_bits() < 32);

    int n = in_msg_body~load_uint(32);

    slice ds = get_data().begin_parse();
    int total = ds~load_uint(64);

    total += n;

    set_data(begin_cell().store_uint(total, 64).end_cell());
}
Пишем Get-функцию
Любая функция в FunC соответствует следующему паттерну:

[<forall declarator>] <return_type><function_name(<comma_separated_function_args>) <specifiers>

Напишем функцию get_total(), возвращающую Integer и имеющую спецификатор method_id (об этом чуть позже).

int get_total() method_id {
    ;; здесь будет код
}
method_id
Спецификация method_id позволяет вызывать функцию по её названию. Для гет-методов это обязательно.

Берем данные из с4
Для того, чтобы функция возвращала total, хранящееся в контракте, нам надо взять данные из регистра, что мы уже делали:

int get_total() method_id {
    slice ds = get_data().begin_parse();
    int total = ds~load_uint(64);

    return total;
}
Весь код нашего смарт-контракта
#include "imports/stdlib.fc";

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    throw_if(35,in_msg_body.slice_bits() < 32);

    int n = in_msg_body~load_uint(32);

    slice ds = get_data().begin_parse();
    int total = ds~load_uint(64);

    total += n;

    set_data(begin_cell().store_uint(total, 64).end_cell());
}

int get_total() method_id {
    slice ds = get_data().begin_parse();
    int total = ds~load_uint(64);

    return total;
}
Пишем обёртку для контракта на TypeScript
Мы хотим иметь возможность взаимодействовать с нашим смарт-контрактом. Для этого напишем так называемую обёртку на языке TypeScript (типизированный JavaScript).

Перейдите в директорию wrappers проекта и откройте файл Counter.ts. Большая часть обёртки уже присутствует по умолчанию. Сейчас нам нужно лишь дополнить ту часть, где задаются данные контракта для деплоя, и добавить две функции для взаимодействия: отправка чисел контракту и вызов гет-метода get_total().

Устанавливаем данные для деплоя
Эти строчки отвечают за то, что мы хотим устанавливать в данные контракта (ячейка c4):

export type CounterConfig = {};

export function counterConfigToCell(config: CounterConfig): Cell {
    return beginCell().endCell();
}
CounterConfig — это объект, в который при необходимости мы можем добавить значения, которыми будет инициализироваться контракт. counterConfigToCell — это функция, которая преобразовывает тот самый объект в ячейку, которая готова к записи в данные контракта для деплоя.

В нашем случае в данных контракта должно лежать всего одно число длины 64 бита. CounterConfig нам не понадобится, а вот функцию обновить нужно.

Функция возвращает только одну ячейку, в которую мы записываем данные для деплоя контракта. Добавим туда запись числа 0 длиной 64 бита:

return beginCell().storeUint(0, 64).endCell();
Теперь при создании контракта в его данных сразу будет лежать число 0.

Метод для отправки сообщений с числами
Ниже в том же файле инициализируется класс Counter, в котором мы можем изменять старые и добавлять новые методы для взаимодействия с контрактом. По умолчанию там уже есть методы для инициализации контракта либо из конфига, либо из адреса уже задеплоенного контракта, а также готовый метод для деплоя.

Давайте добавим метод, с помощью которого мы сможем отправить контракту сообщение для увеличения числа total.

Все методы обёртки, которые отправляют сообщения, должны иметь префикс send в начале. Все методы обёртки, которые вызывают гет-методы, должны иметь префикс get в начале.

Для удобства можем скопировать метод sendDeploy, переименовать его в sendNumber и потом уже изменить только то, что будет нужно.

async sendNumber(provider: ContractProvider, via: Sender, value: bigint) {
    await provider.internal(via, {
        value,
        sendMode: SendMode.PAY_GAS_SEPARATELY,
        body: beginCell().endCell(),
    });
}
Этот метод принимает объекты provider и via, которые определяют, куда и от кого нужно отправить сообщение соответственно. Также передаётся число value, которое означает, сколько Toncoin мы хотим прикрепить к отправляемому сообщению.

В теле метода вызывается функция provider.internal(), которая отправляет сообщение на наш контракт. Она принимает объект via, который мы получили ранее, а также параметры отправляемого сообщения. Эти параметры нам и нужно сейчас изменить.

Как мы помним, наш смарт-контракт ожидает от получаемого сообщения лишь одно число длиной 32 бита. Давайте добавим аргумент для нашего метода и изменим параметр body:

async sendNumber(provider: ContractProvider, via: Sender, value: bigint, number: bigint) {
    await provider.internal(via, {
        value,
        sendMode: SendMode.PAY_GAS_SEPARATELY,
        body: beginCell().storeUint(number, 32).endCell(),
    });
}
Лучше всегда использовать тип bigint для чисел в обёртках смарт-контрактов, так как он поддерживает очень большие числа и является более точным, чем number.

Метод для вызова get_total
Добавим метод, который будет вызывать get_total у нашего контракта:

async getTotal(provider: ContractProvider) {
    // тут будет код
}
Он уже не должен принимать параметры via и value, так как при вызове гет-методов никаких сообщений контракту не посылается.

Добавим вызов get_total. Для этого используем функцию provider.get, которая принимает два параметра: название гет-метода и аргументы, которые в него следует передать. В нашем случае название это "get_total", а список аргументов пустой.

const result = (await provider.get('get_total', [])).stack;
Теперь вернём из нашей функции getTotal полученное в результате число:

return result.readBigNumber();
Весь код обёртки
import {
    Address,
    beginCell,
    Cell,
    Contract,
    contractAddress,
    ContractProvider,
    Sender,
    SendMode,
} from 'ton-core';

export type CounterConfig = {};

export function counterConfigToCell(config: CounterConfig): Cell {
    return beginCell().storeUint(0, 64).endCell();
}

export class Counter implements Contract {
    constructor(
        readonly address: Address,
        readonly init?: { code: Cell; data: Cell }
    ) {}

    static createFromAddress(address: Address) {
        return new Counter(address);
    }

    static createFromConfig(config: CounterConfig, code: Cell, workchain = 0) {
        const data = counterConfigToCell(config);
        const init = { code, data };
        return new Counter(contractAddress(workchain, init), init);
    }

    async sendDeploy(provider: ContractProvider, via: Sender, value: bigint) {
        await provider.internal(via, {
            value,
            sendMode: SendMode.PAY_GAS_SEPARATELY,
            body: beginCell().endCell(),
        });
    }

    async sendNumber(
        provider: ContractProvider,
        via: Sender,
        value: bigint,
        number: bigint
    ) {
        await provider.internal(via, {
            value,
            sendMode: SendMode.PAY_GAS_SEPARATELY,
            body: beginCell().storeUint(number, 32).endCell(),
        });
    }

    async getTotal(provider: ContractProvider) {
        const result = (await provider.get('get_total', [])).stack;
        return result.readBigNumber();
    }
}
Деплоим контракт в тестовую сеть
Для деплоя в тестовую сеть будем использовать интерфейс для командной строки Blueprint, который был установлен автоматически при создании проекта.

npx blueprint run

Далее следуем инструкциям. Выбираем тестовую сеть - testnet. Затем требуется способ авторизации кошелька, с которого будет производиться деплой. Можно подключить Tonkeeper или Tonhub, если выбрать первый пункт TON Connect. В консоли появится QR-код, который нужно отсканировать из приложения вашего кошелька на телефоне. Если такой способ не устраивает, можете воспользоваться одним из других предложенных способов.

После успешного подключения кошелька, вероятно, потребуется подтвердить отправку транзакции из приложения. Если вы всё сделали правильно, в консоли увидите сообщение о том, что контракт успешно задеплоен.

Что делать, если пишет, что не хватает Toncoin?
Необходимо получить их из тестового крана, бот для этого — @testgiver_ton_bot.

Чтобы проверить, пришли ли тонкоины на ваш кошелек в тестовой сети, можете использовать вот этот explorer: https://testnet.tonscan.org/

Важно: Речь идет только о тестовой сети

Проверяем контракт
Вызов recv_internal()
Для вызова recv_internal() необходимо послать сообщение внутри сети TON. Для этого мы создали метод sendNumber в обёртке. Чтобы воспользоваться этим методом и отправить сообщение с кошелька, напишем небольшой скрипт на TypeScript, который будет отправлять сообщение в наш контракт, используя обёртку.

Скрипт сообщения
Создадим в папке scripts файл sendNumber.ts и напишем в нем следующий код (большую часть которого можно скопировать из файла deployCounter.ts той же папки):

import { toNano } from 'ton-core';
import { Counter } from '../wrappers/Counter';
import { compile, NetworkProvider } from '@ton-community/blueprint';

export async function run(provider: NetworkProvider) {
    const counter = provider.open(
        Counter.createFromConfig({}, await compile('Counter'))
    );

    // тут будет код
}
Этот код объявляет единственную функцию run, в которой мы можем взаимодействовать с нашим смарт-контрактом. Для этого создаётся объект counter класса-обёртки, который мы писали выше в этом уроке. Теперь добавим в функцию вызов метода sendNumber:

await counter.sendNumber(provider.sender(), toNano('0.01'), 123n);
Чтобы запустить скрипт, снова исполните команду npx blueprint run в консоли, но в этот раз выберите нужный скрипт - то есть sendNumber. Скорее всего, кошелёк уже будет подключен с момента деплоя, поэтому снова авторизацию проходить не понадобится.

Если вы видите в консоли надпись "Sent transaction", то наше сообщение контракту отправилось. Теперь давайте проверим, обновилось ли число в данных контракта, с помощью метода getTotal.

Скрипт гет-метода
Создадим ещё один файл в директории scripts, например getTotal.ts и снова скопируем тот же код в него, но в этот раз воспользуемся нашим методом getTotal() из обёртки.

import { toNano } from 'ton-core';
import { Counter } from '../wrappers/Counter';
import { compile, NetworkProvider } from '@ton-community/blueprint';

export async function run(provider: NetworkProvider) {
    const counter = provider.open(
        Counter.createFromConfig({}, await compile('Counter'))
    );

    console.log('Total:', await counter.getTotal());
}
Аналогично запустим скрипт с помощью команды npx blueprint run, и после выполнения вы должны увидеть в консоли надпись "Total: 123n".

Поздравляю, вы дошли до конца
Задание
Как вы могли заметить, мы не протестировали работу исключений. Модифицируйте сообщение в обёртке таким образом, чтобы смарт-контракт это сделал.


Урок 2 Тесты на FunC для смарт-контракта
Введение
В этом уроке мы напишем тесты для смарт-контракта созданного в первом уроке в блокчейне TON и выполним их с помощью Blueprint.

Требования
Для прохождения данного урока вам достаточно установить Node.js (желательно версии 18 или выше) и пройти первый урок.

Teсты для первого смарт-контракта
Для нашего первого смарт-контракта мы напишем следующие тесты:

вызовем recv_internal() с разными числами и проверим метод get_total
проверим вызов ошибки при не соответствии числа условию битности
Структура тестов в Blueprint
Для тестирования смарт-контрактов в Blueprint-проектах используется библиотека Sandbox. Она установлена по-умолчанию во всех проектах, созданных через Blueprint.

Сами тесты находятся в папке tests/. Для каждого смарт-контракта проекта (их может быть несколько) создаётся отдельный файл. В нашем случае в этой папке должен лежать лишь один файл Counter.spec.ts. В нём уже написано всё что нужно для тестирования нашего смарт-контракта, и даже прописан первый тест, который проверяет, что контракт успешно деплоится. Остаётся только добавить новые тесты.

Важный момент
Если запустить тесты командой npx blueprint test в текущем положении, вы увидите ошибку в единственном тесте, называющемся "should deploy". В большинстве случаев, этот тест должен сразу выполняться успешно. Но наш контракт по-просту вызывает ошибку, потому что в полученном при деплое сообщении не лежит 32-битное число (в первом уроке мы специально добавили вызов такой ошибки при отсуствии числа).

Чтобы исправить это и игнорировать ошибку при деплое - найдите фрагмент кода, в котором проверяется успешность деплоя. Из него нужно убрать проверку на success. Должно получиться так:

expect(deployResult.transactions).toHaveTransaction({
    from: deployer.address,
    to: counter.address,
    deploy: true,
});
Теперь, если выполнить команду npx blueprint test в терминале вы увидите следующее:

 PASS  tests/Counter.spec.ts
  Counter
    ✓ should deploy (123 ms)

Test Suites: 1 passed, 1 total
Tests:       1 passed, 1 total
Snapshots:   0 total
Time:        1.085 s, estimated 2 s
Ran all test suites.
✨  Done in 2.47s.
Что означает успешное прохождение теста.

Тестируем вызов recv_internal() и get_total()
Напишем первый тест и разберем его код.

После стандартного теста it('should deploy', ...) напишем новый:

it('should update the number', async () => {
    // здесь будет код
});
Строка "should update the number" может быть любой. Это лишь пояснение для нас самих, в чём заключается суть теста.

Теперь напишем сам код теста:

it('should update the number', async () => {
    const caller = await blockchain.treasury('caller');

    await counter.sendNumber(caller.getSender(), toNano('0.01'), 10n);
    expect(await counter.getTotal()).toEqual(10n);

    await counter.sendNumber(caller.getSender(), toNano('0.01'), 5n);
    expect(await counter.getTotal()).toEqual(15n);

    await counter.sendNumber(caller.getSender(), toNano('0.01'), 1000n);
    expect(await counter.getTotal()).toEqual(1015n);
});
Разбираем
const caller = await blockchain.treasury('caller'); - здесь мы создаём новый Treasury, на котором в Sandbox уже лежит миллион монет для всех необходимых проверок. С него мы сможем отправлять сообщения контракту. По сути это просто кошелёк с балансом для тестов.

await counter.sendNumber(caller.getSender(), toNano('0.01'), 10n); - отправляем сообщение с числом 10, используя метод из обёртки, которую мы писали в первом уроке. В качестве отправителя используем caller, созданный выше.

expect(await counter.getTotal()).toEqual(10n); - проверяем (функция expect), что результат гет-метода getTotal() будет равен 10. Если это не так, то тест будет помечен как провалившийся и в терминале мы увидим где именно не прошла проверка. Если всё хорошо и результат совпадёт, то код просто будет исполняться дальше.

В следующих строках мы просто отправляем тому же контракту числа и сверяем результат getTotal(). После отправки 5 наша сумма должна уже равняться 15, а если отправить ещё 1000, то получится 1015. Если FunC код контракта написан правильно, тест должен быть помечен как пройденный.

Запустим тесты командой npx blueprint test, и если вы всё сделали без ошибок, получится следующий результат:

 PASS  tests/Counter.spec.ts
  Counter
    ✓ should deploy (126 ms)
    ✓ should update the number (79 ms)
Галочка означает, что наш новый тест успешно пройден.

Тестируем исключение
Напишем ещё один тест и разберем его код.

it('should throw error when number is not 32 bits', async () => {
    const caller = await blockchain.treasury('caller');

    const result = await counter.sendDeploy(caller.getSender(), toNano('0.01'));
    expect(result.transactions).toHaveTransaction({
        from: caller.address,
        to: counter.address,
        success: false,
        exitCode: 35,
    });
});
Разбираем
const caller = await blockchain.treasury('caller'); - здесь мы создаём новый Treasury, на котором в Sandbox уже лежит миллион монет для всех необходимых проверок. С него мы сможем отправлять сообщения контракту. По сути это просто кошелёк с балансом для тестов.

const result = await counter.sendDeploy(caller.getSender(), toNano('0.01')); - отправляем пустое сообщение без числа (именно такое использовалось для деплоя, поэтому для простоты мы и используем готовую функцию sendDeploy).

expect(result.transactions).toHaveTransaction({ ... }) - проверяем (функция expect), что среди транзакций, которые в результате вызова контракта обработались, будет транзакция с ошибкой 35.

Код ошибки 35 потому что именно это число мы прописали в смарт-контракте в функции throw_if

Запустим тесты командой npx blueprint test, и если вы всё сделали без ошибок, получится следующий результат:

 PASS  tests/Counter.spec.ts
  Counter
    ✓ should deploy (127 ms)
    ✓ should update the number (79 ms)
    ✓ should throw error when number is not 32 bits (53 ms)
Галочка означает, что наш новый тест успешно пройден.

На этом всё!
Вы прошли второй урок и успешно реализовали тесты для смарт-контракта.

P.S если есть какие-то вопросы, предлагаю задавать здесь


Урок 4 Тесты на FunC для прокси смарт-контракта
Введение
В этом уроке мы напишем тесты для смарт-контракта созданного в третьем уроке в блокчейне TON и выполним их с помощью Blueprint.

Требования
Для прохождения данного урока вам достаточно установить Node.js. Желательно устанавливать одну из последних версий, например 18.

А также пройти третий урок.

Teсты для прокси смарт-контракта
Для нашего прокси смарт-контракта мы напишем следующие тесты:

При отправке сообщения в контракт от владельца пересылка не должна осуществляться
Остальные условия третьего урока должны выполняться
Тестируем вызов прокси контракта его владельцем
Откроем файл tests/Proxy.spec.ts, в котором уже написана база для наших тестов. В нём для удобства вынесем объявление deployer за пределы функции beforeEach, чтобы можно было к нему обращаться из всех тестов. Также нужно добавить в конфиг контаркта при деплое те параметры, которые мы в нём задавали. Должно получиться примерно так:

let blockchain: Blockchain;
let proxy: SandboxContract<Proxy>;
let deployer: SandboxContract<TreasuryContract>;

beforeEach(async () => {
    blockchain = await Blockchain.create();

    deployer = await blockchain.treasury('deployer');

    proxy = blockchain.openContract(
        Proxy.createFromConfig(
            {
                owner: deployer.address,
            },
            code
        )
    );

    const deployResult = await proxy.sendDeploy(
        deployer.getSender(),
        toNano('0.01')
    );

    expect(deployResult.transactions).toHaveTransaction({
        from: deployer.address,
        to: proxy.address,
        deploy: true,
    });
});
Теперь напишем первый тест для прокси контракта и разберем его код.

it('should not forward from owner', async () => {
    const result = await deployer.send({
        to: proxy.address,
        value: toNano('1'),
    });
    expect(result.transactions).not.toHaveTransaction({
        from: proxy.address,
        to: deployer.address,
    });
});
Сначала мы отправляем сообщение с кошелька deployer на proxy с суммой 1 TON.

Как мы помним, наш контракт не должен пересылать сообщения от владельца ему же самому. Поэтому условием прохождения теста должно быть отсутствие такой транзакции. Такую проверку можно реализовать, добавив .not перед .toHaveTransaction.

Примечание: условия для тестов (ключевое слово expect) работают через библиотеку Jest. Её синтаксис довольно простой и зачастую можно догадаться как что-то проверить, просто написав это по-английски. Названия всех функций чётко отражают её суть. Например toEqual проверяет, что два значения равны, а toBeLessThan проверяет, что одно значение меньше другого.

Получаем условие, что в результате выполнения всей цепочки действий не должно быть ни одной транзакции от proxy к deployer.

Тестируем вызов прокси контракта другим кошельком
Напишем второй тест для прокси контракта и разберем его код.

it('should forward from another wallet', async () => {
    let user = await blockchain.treasury('user');
    const result = await user.send({
        to: proxy.address,
        value: toNano('1'),
        body: beginCell().storeStringTail('Hello, world!').endCell(),
    });
    expect(result.transactions).toHaveTransaction({
        from: proxy.address,
        to: deployer.address,
        body: beginCell()
            .storeAddress(user.address)
            .storeRef(beginCell().storeStringTail('Hello, world!').endCell())
            .endCell(),
        value: (x) => (x ? toNano('0.99') <= x && x <= toNano('1') : false),
    });
});
Сначала создаём новый кошелёк так же, как в коде выше создаётся deployer:

let user = await blockchain.treasury('user');
Далее посылаем сообщение от user к proxy с суммой 1 TON и комментарием Hello, world!.

Теперь наш контракт уже должен перенаправить это сообщение к владельцу. Поэтому проверяем, что оно там действительно есть через .toHaveTransaction без использования .not. Также для более точной проверки мы используем параметры body и value.

В body должна лежать ячейка, содержащая адрес отправителя исходного сообщения (то есть user.address), а затем в рефе должно лежать исходное тело сообщения. Поэтому проверяем, чтобы body был равен

beginCell().storeAddress(user.address)
    .storeRef(beginCell().storeStringTail('Hello, world!').endCell())
.endCell()
Для проверки value используется необычная конструкция, давайте разберём её детальнее:

value: (x) => (x ? toNano('0.99') <= x && x <= toNano('1') : false);
"Мэтчеры" из .toHaveTransaction могут принимать как само значение, которое мы ожидаем, так и функцию, которая делает какую-то более сложную проверку и возвращает булевое значение с результатом этой проверки. В нашем случае, мы не знаем какую точно сумму отправит прокси-контракт владельцу, ведь мы для отправки используем в контракте режим 64, а значит комиссии вычтутся из суммы сообщения. Поэтому мы хотим проверить, что сумма сообщения приблизительно равна 1. Для этого мы пишем так назвыаемую "стрелочную функцию", которую не надо объявлять заранее. Эта функция принимает какое-то значение x и возврашает true если оно больше или равно 0.99 TON и меньше или равно 1 TON. Также тернарным выражением мы проверяем, что x не является undefined чтобы мы могли провести проверку на его значение, а в противном случае возвращаем false.

Запускаем тесты
Выполним в терминале команду npx blueprint test. Результат должен быть примерно такой:

 PASS  tests/Proxy.spec.ts
  Proxy
    ✓ should deploy (145 ms)
    ✓ should not forward from owner (63 ms)
    ✓ should forward from another wallet (66 ms)
Если какие то тесты у вас не прошли, просмотрите код и текст этого урока ещё раз. Также сверьте свой код смарт-контракта с кодом из предыдущего урока.

Заключение
В этом уроке мы успешно протестироавли наш прокси-контракт и убедились, что он работает как надо.



ChatGPT сказал:
Рассуждали о создании и тестировании смарт-контракта для 14 секунд
Ниже приведён один из вариантов, как можно модифицировать отправляемое сообщение так, чтобы в смарт-контракт поступало меньше 32 бит и он выбрасывал ошибку с кодом 35.

1. Добавляем новый метод в обёртку
В файле Counter.ts (где у нас написан класс Counter) добавим метод sendInvalidNumber, который будет отправлять в тело сообщения, скажем, только 16 бит вместо 32:

ts
Копировать
Редактировать
async sendInvalidNumber(
    provider: ContractProvider,
    via: Sender,
    value: bigint
) {
    await provider.internal(via, {
        value,
        sendMode: SendMode.PAY_GAS_SEPARATELY,
        // Пишем только 16 бит вместо 32
        body: beginCell().storeUint(1, 16).endCell(),
    });
}
Обратите внимание, что мы использовали storeUint(1, 16). Это значит, что в сообщение запишется только 16 бит (два байта). В вашем случае вы можете записать любое меньшее 32 бит число (хоть 31, хоть 8), либо вовсе не писать число, оставив пустой beginCell().endCell(). Главное — не достигать порога в 32 бита.

2. Вызываем метод в скрипте
Затем в любом скрипте из папки scripts (например, создадим scripts/sendInvalidNumber.ts), можно проверить:

ts
Копировать
Редактировать
import { toNano } from 'ton-core';
import { Counter } from '../wrappers/Counter';
import { compile, NetworkProvider } from '@ton-community/blueprint';

export async function run(provider: NetworkProvider) {
    const counter = provider.open(
        Counter.createFromConfig({}, await compile('Counter'))
    );

    // Отправляем «неправильное» сообщение
    await counter.sendInvalidNumber(provider.sender(), toNano('0.01'));
    console.log('Invalid message was sent');
}
Запускать этот скрипт, как обычно:

bash
Копировать
Редактировать
npx blueprint run
и выбираем sendInvalidNumber.

3. Проверяем результат
При отправке такого сообщения смарт-контракт, увидев что slice_bits() < 32, должен выполнить строку:

funC
Копировать
Редактировать
throw_if(35, in_msg_body.slice_bits() < 32);
и выбросить исключение с кодом 35. Это будет видно либо в логе транзакций при локальном тестировании (через npx blueprint test в тестах Sandbox), либо при отправке в тестовую сеть (в npx blueprint run).

Таким образом вы вызываете ветку кода со сгенерированным исключением и убеждаетесь, что контракт корректно выбрасывает ошибку при слишком коротком теле сообщения.







Вы сказали:
Урок 5 Запоминаем Адрес и идентифицируем операцию
Введение
В этом уроке мы напишем смарт-контракт, который умеет производить разные операции в зависимости от флага, в блокчейне TON на языке FunC, а протестируем его уже в следующем уроке.

Требования
Для прохождения данного урока вам достаточно установить Node.js. Желательно устанавливать одну из последних версий, например 18.

А также уметь создавать/деплоить проект с помощью Blueprint. Научиться этому можно в первом уроке.

Op - для идентификации операции
Прежде чем рассматривать что за смарт-контракт мы будем делать в этом уроке, предлагаю изучить рекомендации о теле сообщения смарт-контракта (message body).

Чтобы мы могли создавать подобие клиент-серверной архитектуры на смарт-контрактах, рекомендуется начинать каждое сообщение (строго говоря тело сообщения) с некоторого 32-битного флага op, который будет идентифицировать какую операцию должен выполнить смарт-контракт. Сам контракт в свою очередь, на основе значения этого флага, должен выполнить нужную операцию, и при необходимости отправить ответное сообщение, которое также будет включать в себя какой-то op.

В этом уроке мы будем делать смарт-контракт, который выполняет различные действия в зависимости от op.

Смарт-контракт
Задача смарт-контракта будет запоминать адрес, устанавливаемый менеджером и сообщать его всем, кто запросит, в частности следующая функциональность**:

когда контракт получает сообщение от Менеджера с op равным 1 за которым следует какой-то query_id, за которым следует MsgAddress, он должен сохранить полученный адрес в хранилище.
когда контракт получает внутреннее сообщение с любого адреса с op, равным 2, за которым следует query_id, он должен ответить отправителю сообщением с телом, содержащим:
op равным 3
тот же query_id
Адрес менеджера
Адрес, который был запомнен с момента последнего запроса менеджера (пустой адрес addr_none, если еще не было запроса менеджера)
Значение TON, прикрепленное к сообщению за вычетом платы за обработку.
когда смарт-контракт получает любое другое сообщение, он должен выдать исключение.
** идеи для смарт-контрактов я решил брать из задач FunC contest1, так как они очень хорошо подходят для ознакомления с разработкой смарт-контрактов для TON.

Структура смарт-контракта
Внешний метод
Для того, чтобы наша прокси могла принимать сообщения будем использовать внешний метод recv_internal(), как и в предыдущих уроках.

() recv_internal(int balance, int msg_value, cell in_msg_full, slice in_msg_body)  {

}
Внутри метода
Внутри метода мы из аргументов функции возьмем op, query_id, и адрес отправителя sender_address, а потом с помощью условных операторов построим логику вокруг op.

() recv_internal (int balance, int msg_value, cell in_msg_full, slice in_msg_body) {
 ;; возьмем  op, query_id, и адрес отправителя sender_address

  if (op == 1) {
	;; здесь будем сохранять адрес полученный от менеджера
  } elseif (op == 2) {
      ;; отправка сообщения
  } else {
      ;; здесь будет исключение
  }
}
Вспомогательные функции
Давайте подумаем, какую функциональность можно вынести в функции?

сравнение адресов, чтобы при op равному 1 проверить, что запрос пришел от Менеджера.
выгрузка и загрузка адреса менеджера и адреса, который мы сохраняем в постоянных данных контракта.
спарсить адрес отправителя из входящего сообщения.
Сравнение адресов
FunC поддерживает определение функции на ассемблере (имеется ввиду Fift). Происходит это следующим образом - мы определяем функцию как низкоуровневый примтив TVM. Для функции сравнения это будет выглядеть так:

int equal_slices (slice a, slice b) asm "SDEQ";
Как вы можете видеть, используется ключевое слово asm

Посмотреть список возможных примитивов можно в документации.

Выгрузить адреса из постоянных данных
Хранить адреса мы будем в слайсах, но исходя из задачи хранить нам предстоит два адреса, адрес Менеджера, для проверки и адрес, который пришлет менеджер для хранения. Поэтому слайсы будем возвращать в кортеже.

Для того чтобы "достать" постоянные данные нам понадобятся две функции из стандартной библиотеки FunC.

А именно: get_data - берет ячейку из постоянных данных. begin_parse - ячейку преобразует в slice

Передадим это значение в переменную ds:

var ds = get_data().begin_parse()

Загрузим из сообщения адрес с помощью load_msg_addr() - которая загружает из слайса единственный префикс, который является допустимым MsgAddress. У нас их два, так что 'вычитаем' два раза.

return (ds~load_msg_addr(), ds~load_msg_addr());

Итого получим следующую функцию:

(slice, slice) load_data () inline {
  var ds = get_data().begin_parse();
  return (ds~load_msg_addr(), ds~load_msg_addr());
}
Inline
В прошлых уроках мы уже использовали спецификатор inline, который фактически подставляет код в каждом месте вызова функции. В этом уроке рассмотрим, зачем это необходимо с практической точки зрения.

Как мы знаем из документации комиссия за транзакцию состоит из:

storage_fees - комиссия за место в блокчейне.
in_fwd_fees - комиссия за импорт сообщений(это случай когда обрабатываем external messages).
computation_fees - комиссии за выполнение инструкций TVM.
action_fees - комиссии, связанная с обработкой списка действий (например отправка сообщений).
out_fwd_fees - комиссия за импорт исходящих сообщений.
Подробнее здесь. Собственно спецификатор inline позволяет сэкономить computation_fee.

По умолчанию, когда у вас есть функция funC, она получает свой собственный идентификатор, хранящийся в отдельном словаре id->function, и когда вы вызываете ее где-то в программе, происходит поиск функции в словаре и последующий переход.

Спецификатор же inline помещает тело функции прямо в код родительской функции.

Поэтому если функция используется только один или два раза, часто гораздо дешевле объявить эту функцию inline, то есть встроенной, так как переход к ссылке намного дешевле, чем поиск и переход по словарю.

Загрузить адреса в постоянные данные
Конечно же по мимо выгрузки нужна загрузка. Сделаем функцию, которая сохраняет адрес менеджера и адрес который менеджер отправит:

() save_data (slice manager_address, slice memorized_address) impure inline {

}
Замечу, что фукнция имеет спецификатор impure. И мы должны указать impure спецификатор, если функция может изменять хранилище контракта. Иначе компилятор FunC может удалить этот вызов функции.

Для того чтобы "сохранить" постоянные данные нам понадобятся функции из стандартной библиотеки FunC.

А именно:

begin_cell() - создаст Builder для будущей ячейки store_slice() - cохранит Slice(слайс) в Builder end_cell() - создат Cell (ячейку)

set_data() - запишет ячейку в постоянные данные

Собираем ячейку:

begin_cell().store_slice(manager_address).store_slice(memorized_address).end_cell()
Загружаем её в постоянные данные контракта:

set_data(begin_cell().store_slice(manager_address).store_slice(memorized_address).end_cell());
Итого получим следующую функцию:

() save_data (slice manager_address, slice memorized_address) impure inline {
	  set_data(begin_cell().store_slice(manager_address).store_slice(memorized_address).end_cell());
}
Парсим адрес отправителя из входящего сообщения
Объявим функцию, с помощью который мы сможем достать адрес отправителя из ячейки сообщения. Функция будет возвращать слайс, так как сам адрес мы будем брать с помощью load_msg_addr() - которая загружает из слайса единственный префикс, который является допустимым MsgAddress и возвращает его в слайс.

slice parse_sender_address (cell in_msg_full) inline {
  return sender_address;
}
Теперь используя уже знакомую нам begin_parse преобразуем ячейку в слайс.

slice parse_sender_address (cell in_msg_full) inline {
  var cs = in_msg_full.begin_parse();
  return sender_address;
}
Начинаем "вычитывать" ячейку с помощью load_uint, функции из стандартной библиотеки FunC она загружает целое число n-бит без знака из слайса.

В данном уроке мы не будем останавливаться подробно на флагах, но подробнее можно прочитать в документации. Ну и наконец берем адрес.

Итого получим следующую функцию:

slice parse_sender_address (cell in_msg_full) inline {
  var cs = in_msg_full.begin_parse();
  var flags = cs~load_uint(4);
  slice sender_address = cs~load_msg_addr();
  return sender_address;
}
Промежуточный итог
На данный момент у нас готовый вспомогательные функции и тело основной функции данного смарт-контракта recv_internal().

#include "imports/stdlib.fc";

int equal_slices (slice a, slice b) asm "SDEQ";

(slice, slice) load_data () inline {
  var ds = get_data().begin_parse();
  return (ds~load_msg_addr(), ds~load_msg_addr());
}

() save_data (slice manager_address, slice memorized_address) impure inline {
  set_data(begin_cell().store_slice(manager_address).store_slice(memorized_address).end_cell());
}

slice parse_sender_address (cell in_msg_full) inline {
  var cs = in_msg_full.begin_parse();
  var flags = cs~load_uint(4);
  slice sender_address = cs~load_msg_addr();
  return sender_address;
}

	() recv_internal (int balance, int msg_value, cell in_msg_full, slice in_msg_body) {
	 ;; возьмем  op query_id, и адрес отправителя sender_address

	  if (op == 1) {
		;; здесь будем сохранять адрес полученный от менеджера
	  } elseif (op == 2) {
		;; отправка сообщения
	  } else {
		;; здесь будет исключение
	  }
	}
Осталось только наполнить recv_internal().

Наполняем внешний метод
Берем op query_id, и адрес отправителя sender_address
Из тела сообщения считываем op и query_id соответственно. По рекомендациям это 32 и 64 битные значения.

А также с помощью функции parse_sender_address(), которую мы написали выше возьмем адрес отправителя.

	() recv_internal (int balance, int msg_value, cell in_msg_full, slice in_msg_body) {
	int op = in_msg_body~load_int(32);
	int query_id = in_msg_body~load_uint(64);
	var sender_address = parse_sender_address(in_msg_full);

	  if (op == 1) {
		;; здесь будем сохранять адрес полученный от менеджера
	  } elseif (op == 2) {
		;; отправка сообщения
	  } else {
		;; здесь будет исключение
	  }
	}
Флаг op == 1
В соответствии с заданием при флаге 1, мы должны получив адреса менеджера и сохраненный адрес, проверить что адрес отправителя равен адресу менеджера(только менеджер может менять адрес) и сохранить новый адрес, который храниться в теле сообщения.

Загрузим из постоянных данных адрес менеджера manager_address и сохраненный адрес memorized_address) используя функцию load_data() написанную ранее.

(slice manager_address, slice memorized_address) = load_data();
Используя функцию equal_slices и унарный оператор ~, который является побитовым не, проверяем равенство адрес, выдавая исключение если это адреса не равны.

(slice manager_address, slice memorized_address) = load_data();
throw_if(1001, ~ equal_slices(manager_address, sender_address));
Возьмем адрес, с помощью уже знакомой load_msg_addr() и сохраним адреса используя написанную ранее функцию save_data().

(slice manager_address, slice memorized_address) = load_data();
throw_if(1001, ~ equal_slices(manager_address, sender_address));
slice new_memorized_address = in_msg_body~load_msg_addr();
save_data(manager_address, new_memorized_address);
Флаг op == 2
В соответствии с заданием при флаге 2 мы должны отправить сообщением с телом, содержащим:

op равна 3
тот же query_id
Адрес менеджера
Адрес, который был запомнен с момента последнего запроса менеджера (пустой адрес addr_none, если еще не было запроса менеджера)
Значение TON, прикрепленное к сообщению за вычетом платы за обработку.
Прежде чем отправлять сообщение загрузим адреса, хранящиеся в контракте.

 (slice manager_address, slice memorized_address) = load_data();
С полной структурой сообщения можно ознакомиться здесь - message layout. Но обычно нам нет необходимости контролировать каждое поле, поэтому можно использовать краткую форму из примера:

	 var msg = begin_cell()
		.store_uint(0x18, 6)
		.store_slice(addr)
		.store_coins(amount)
		.store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
		.store_slice(message_body)
	  .end_cell();
Полный разбор сообщений в TON есть в третьем уроке.

Отправка сообщения в соответствии с условиями:

(slice manager_address, slice memorized_address) = load_data();
  var msg = begin_cell()
          .store_uint(0x10, 6)
          .store_slice(sender_address)
          .store_grams(0)
          .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
          .store_uint(3, 32)
          .store_uint(query_id, 64)
          .store_slice(manager_address)
          .store_slice(memorized_address)
        .end_cell();
  send_raw_message(msg, 64);
Исключение
Здесь все просто используем обычный throw из встроенных модулей FunC.

throw(3);
##Полный код смарт-контракта

#include "imports/stdlib.fc";

int equal_slices (slice a, slice b) asm "SDEQ";

(slice, slice) load_data () inline {
    var ds = get_data().begin_parse();
    return (ds~load_msg_addr(), ds~load_msg_addr());
}

() save_data (slice manager_address, slice memorized_address) impure inline {
    set_data(begin_cell().store_slice(manager_address).store_slice(memorized_address).end_cell());
}

slice parse_sender_address (cell in_msg_full) inline {
    var cs = in_msg_full.begin_parse();
    var flags = cs~load_uint(4);
    slice sender_address = cs~load_msg_addr();
    return sender_address;
}

() recv_internal (int balance, int msg_value, cell in_msg_full, slice in_msg_body) {
    int op = in_msg_body~load_int(32);
    int query_id = in_msg_body~load_uint(64);
    var sender_address = parse_sender_address(in_msg_full);

    if (op == 1) {
        (slice manager_address, slice memorized_address) = load_data();
        throw_if(1001, ~ equal_slices(manager_address, sender_address));
        slice new_memorized_address = in_msg_body~load_msg_addr();
        save_data(manager_address, new_memorized_address);
    } elseif (op == 2) {
        (slice manager_address, slice memorized_address) = load_data();
        var msg = begin_cell()
            .store_uint(0x10, 6)
            .store_slice(sender_address)
            .store_grams(0)
            .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
            .store_uint(3, 32)
            .store_uint(query_id, 64)
            .store_slice(manager_address)
            .store_slice(memorized_address)
        .end_cell();
        send_raw_message(msg, 64);
    } else {
        throw(3);
    }
}
Обёртка на TypeScript
Для удобного взаимодействия с нашим смарт-контрактом, напишем обёртку на TypeScript. База для неё уже предоставляется от Blueprint.

Конфиг данных контракта
Откроем файл wrappers/AddressSaver.ts (название файла может быть другим, смотря как вы создавали проект). Начнём с изменений в конфиге данных. Наш контракт содержит в свои данных два значения - адрес менеджера и сохранённый адрес. Пусть сохранённый адрес по умолчанию будет пустым (пустой адрес можно записать как два нуля, то есть uint2 с значением 0). Добавим эти значения в конфиг:

export type AddressSaverConfig = {
    manager: Address;
};

export function addressSaverConfigToCell(config: AddressSaverConfig): Cell {
    return beginCell().storeAddress(config.manager).storeUint(0, 2).endCell();
}
Теперь перейдём к классу AddressSaver чтобы добавить методы для вызова нужных нам операций.

Метод для вызова op = 1
При вызове операции с кодом 1, в тело сообщения мы должны положить: op=1, query_id, а также новый адрес, который мы хотим сохранить в контракте. Назовём метод sendChangeAddress (напомню, что методы, которые посылают сообщения на контракт, обязательно должны иметь префикс send).

async sendChangeAddress(provider: ContractProvider, via: Sender, value: bigint, queryId: bigint, newAddress: Address) {
    await provider.internal(via, {
        value,
        sendMode: SendMode.PAY_GAS_SEPARATELY,
        body: beginCell().storeUint(1, 32).storeUint(queryId, 64).storeAddress(newAddress).endCell(),
    });
}
Метод для вызова op = 2
Эта операция не требует дополнительных данных кроме op=2 и query_id. Назовём метод sendRequestAddress.

async sendRequestAddress(provider: ContractProvider, via: Sender, value: bigint, queryId: bigint) {
    await provider.internal(via, {
        value,
        sendMode: SendMode.PAY_GAS_SEPARATELY,
        body: beginCell().storeUint(2, 32).storeUint(queryId, 64).endCell(),
    });
}
Заключение
Тесты мы напишем в следующем уроке. Плюс хотел сказать отдельное спасибо, тем кто донатит TON для поддержки проекта, это очень мотивирует и помогает выпускать уроки быстрее.

Урок 6 Тесты на FunC для смарт-контракта с op и query_id
Введение
В этом уроке мы напишем тесты для смарт-контракта созданного в пятом уроке в блокчейне TON и выполним их с помощью Blueprint.

Требования
Для прохождения данного урока вам достаточно установить Node.js. Желательно устанавливать одну из последних версий, например 18.

А также пройти пятый урок.

Задание пятого урока
Для удобства напомню здесь, что мы делали в пятом уроке. Задача смарт-контракта будет запоминать адрес, устанавливаемый менеджером и сообщать его всем, кто запросит, в частности следующая функциональность**:

когда контракт получает сообщение от Менеджера с op равным 1 за которым следует какой-то query_id, за которым следует MsgAddress, он должен сохранить полученный адрес в хранилище.
когда контракт получает внутреннее сообщение с любого адреса с op, равным 2, за которым следует query_id, он должен ответить отправителю сообщением с телом, содержащим:
op равна 3
тот же query_id
Адрес менеджера
Адрес, который был запомнен с момента последнего запроса менеджера (пустой адрес addr_none, если еще не было запроса менеджера)
Значение TON, прикрепленное к сообщению за вычетом платы за обработку.
когда смарт-контракт получает любое другое сообщение, он должен выдать исключение.
Teсты для смарт-контракта с op и query_id
Для нашего прокси смарт-контракта мы напишем следующие тесты:

Сохранение адресов с op = 1
Адрес должен иметь возможность сохранять только менеджер
Обработка op = 2
Контракт должен выдавать исключение при любом другом опкоде
Прежде чем перейти к написанию тестов...
Откроем файл tests/AddressSaver.spec.ts (название может отличаться, если вы назвали проект по-другому), в котором будут наши тесты. Вспомним из четвёртого урока, что нужно обновить значения в конфиге при деплое на те, которые мы там задавали. Также для удобства можно вынести объявление объекта deployer за пределы функции beforeEach чтобы иметь к нему доступ из всех тестов.

Тестируем op = 1
Генерируем случайный адрес функцией randomAddress(), а затем вызываем метод sendChangeAddress от имени кошелька deployer.

В таком случае, должна присутствовать транзакция от deployer к AddressSaver с флагом success = true (который означает, что выполнение всех фаз транзакции было успешно).

it('should change saved address by manager', async () => {
    const address = randomAddress();
    const result = await addressSaver.sendChangeAddress(
        deployer.getSender(),
        toNano('0.01'),
        12345n,
        address
    );

    expect(result.transactions).toHaveTransaction({
        from: deployer.address,
        to: addressSaver.address,
        success: true,
    });
});
Тестируем исключение при вызове op = 1 не менеджером
В этом тесте делаем то же самое что и в предыдущем, но вызываем sendChangeAddress от имени другого кошелька user.

В таком случае флаг success должен быть false.

it('should not change saved address by anyone else', async () => {
    let user = await blockchain.treasury('user');
    const address = randomAddress();
    const result = await addressSaver.sendChangeAddress(
        user.getSender(),
        toNano('0.01'),
        12345n,
        address
    );

    expect(result.transactions).toHaveTransaction({
        from: user.address,
        to: addressSaver.address,
        success: false,
    });
});
Тестируем op = 2
Вызываем sendChangeAddress как и в первом тесте чтобы успешно поменять сохранённый адрес. Затем используя новый кошелёк user вызываем sendRequestAddress.

Такой вызов должен спровоцировать транзакцию от AddressSaver к user с телом сообщения, которое содержит в себе op = 3, query_id = 12345, deployer.address, address.

it('should return required data on requestAddress call', async () => {
    const address = randomAddress();
    await addressSaver.sendChangeAddress(
        deployer.getSender(),
        toNano('0.01'),
        12345n,
        address
    );

    let user = await blockchain.treasury('user');
    const result = await addressSaver.sendRequestAddress(
        user.getSender(),
        toNano('0.01'),
        12345n
    );
    expect(result.transactions).toHaveTransaction({
        from: addressSaver.address,
        to: user.address,
        body: beginCell()
            .storeUint(3, 32)
            .storeUint(12345n, 64)
            .storeAddress(deployer.address)
            .storeAddress(address)
            .endCell(),
    });
});
Тестируем исключение при любых других опкодах
Для этого теста будем использовать метод send у контракта Treasury. Отправим, например, сообщение с op = 5.

Такая транзакция должна завершиться с exitCode = 3, что мы и проверяем в тесте.

it('should throw on any other opcode', async () => {
    const result = await deployer.send({
        to: addressSaver.address,
        value: toNano('0.01'),
        body: beginCell().storeUint(5, 32).storeUint(12345n, 64).endCell(),
    });
    expect(result.transactions).toHaveTransaction({
        from: deployer.address,
        to: addressSaver.address,
        exitCode: 3,
    });
});
Запустим тесты командой npx blueprint test и мы должны увидеть следующее:

 PASS  tests/AddressSaver.spec.ts
  AddressSaver
    ✓ should deploy (145 ms)
    ✓ should change saved address by manager (67 ms)
    ✓ should not change saved address by anyone else (67 ms)
    ✓ should return required data on requestAddress call (70 ms)
    ✓ should throw on any other opcode (89 ms)
Если какие то тесты у вас не прошли, просмотрите код и текст этого урока ещё раз. Также сверьте свой код смарт-контракта с кодом из предыдущего урока.

Заключение
Хотел сказать отдельное спасибо, тем кто донатит для поддержки проекта, это очень мотивирует и помогает выпускать уроки быстрее. Если вы хотите помочь проекту (быстрее выпускать уроки, перевести это все на английский итд), внизу на главной странице, есть адреса для донатов.

Урок 7 Hashmap или Словарь
Введение
В этом уроке мы напишем смарт-контракт, который умеет производить разные операции с Hashmap - словарем, в блокчейне TON на языке FunC, а протестируем его уже в следующем уроке.

Требования
Для прохождения данного урока вам достаточно установить Node.js. Желательно устанавливать одну из последних версий, например 18.

А также уметь создавать/деплоить проект с помощью Blueprint. Научиться этому можно в первом уроке.

Hashmap or dictionaries (словари)
Hashmap - это структура данных представленная деревом. Hashmap - отображает ключи, в значения произвольного типа, таким образом, чтобы был возможен быстрый поиск и модификация. В FunC hashmaps представлены ячейкой.

Смарт-контракт
Задача смарт-контракта будет добавлять и удалять данные и key/value хранилища Hashmap в частности следующая функциональность**:

Смарт-контракт при получении сообщения со структурой описанной ниже контракт должен добавить к своим данным новую запись типа ключ/значение:
32-bit unsigined op равный 1
64-bit unsigned query_id
256-bit unsigned key
64-bit valid_until unixtime
оставшийся слайс значение
Сообщение об удалении устаревших данных имеет следующую структуру: - 32-bit unsigined op equal to 2 - 64-bit unsigned query_id При получении такого сообщения контракт должен удалить из своих данных все устаревшие записи (с valid_until < now()). А так же проверить, что в сообщение нет лишних данных кроме 32-bit unsigined op и 64-bit unsigned query_id
Для всех других внутренних сообщений должна быть выдана ошибка
Должен быть реализован Get-метод get_key который принимает 256-битный ключ без знака и должен возвращать целое число valid_until и значение слайса данных для этого ключа. Если для этого ключа нет записи, должна быть выдана ошибка.
Важно! мы предполагаем, что контракт начинает работу с пустым хранилищем.
** идеи для смарт-контрактов я решил брать из задач FunC contest1, так как они очень хорошо подходят для ознакомления с разработкой смарт-контрактов для TON.

Внешний метод
Структура внешнего метода
Для того, чтобы наша прокси могла принимать сообщения будем использовать внешний методrecv_internal()

() recv_internal(int balance, int msg_value, cell in_msg_full, slice in_msg_body)  {

}
Берем данные из тела сообщения
По условию в зависимости от op контракт должен работать по-разному. Поэтому вычитаем op и query_id из тела сообщения.

() recv_internal(int balance, int msg_value, cell in_msg_full, slice in_msg_body) {
	int op = in_msg_body~load_uint(32);
	int query_id = in_msg_body~load_uint(64);
 }
Подробнее про op и query_id можно почитать в пятом уроке.

Также используя условные операторы выстраиваем логику вокруг op

() recv_internal(int balance, int msg_value, cell in_msg_full, slice in_msg_body) {
	int op = in_msg_body~load_uint(32);
	int query_id = in_msg_body~load_uint(64);

	if (op == 1) {
	;; здесь будем добавлять новые значения
	}
	if (op == 2) {
	;; здесь удалять
	}
 }
По заданию для всех других внутренних сообщений должна быть выдана ошибка, поэтому добавим исключение после условных операторов.

() recv_internal(int balance, int msg_value, cell in_msg_full, slice in_msg_body) {
	int op = in_msg_body~load_uint(32);
	int query_id = in_msg_body~load_uint(64);

	if (op == 1) {
	;; здесь будем добавлять новые значения
	}
	if (op == 2) {
	;; здесь удалять
	}
	throw (1001);
 }
Теперь надо взять постоянные данные контракта. Понадобятся две функции из стандартной библиотеки FunC.

А именно: get_data - берет ячейку постоянных данных. begin_parse - ячейку преобразует в slice

Передадим это значение в слайс ds

cell data = get_data();
slice ds = data.begin_parse();
важно учесть замечание в задании, что контракт будет начинать работу с пустыми данными. Поэтому, чтобы корректно проинициализировать эти переменные, воспользуемся условным оператором, синтаксис следующий:

<condition> ? <consequence> : <alternative>
Выглядеть это будет так:

cell dic = ds.slice_bits() == 0 ? new_dict() : data;
Здесь используются следующие функции из стандартной библиотеки FunC:

slice_bits() - возвращает количество битов данных в слайсе, проверяем пустые данные контракта или нет
new_dict()  - создает пустой словарь, который на самом деле является нулевым значением. Частный случай null().
Итого каркас контракта следующий:

#include "imports/stdlib.fc";

() recv_internal(int balance, int msg_value, cell in_msg_full, slice in_msg_body) {
	int op = in_msg_body~load_uint(32);
	int query_id = in_msg_body~load_uint(64);

	cell data = get_data();
	slice ds = data.begin_parse();
	cell dic = ds.slice_bits() == 0 ? new_dict() : data;
	if (op == 1) {
	;; здесь будем добавлять новые значения
	}
	if (op == 2) {
	;; здесь удалять
	}
	throw (1001);
 }
op = 1
При op равному одному мы добавляем значение в hashmap. Соответственно по заданию нам надо:

достать ключ из тела сообщения
установить значение в hashmap(словарь) используя ключ и тело сообщения
сохранить hashmap(словарь)
завершает выполнение функции, чтобы мы не попали на исключение объявленное в конце recv_internal()
Достаем ключ
Здесь все как и раньше, используем load_uint функцию из стандартной библиотеки FunC она загружает целое число n-бит без знака из слайса.

	if (op == 1) {
		int key = in_msg_body~load_uint(256);
	}
Работаем с hashmap
Для добавления данных воспользуемся dict_set которая устанавливает значение, связанное с индексом ключа key n битность в словаре dict, в слайс и возвращает результирующий словарь.

if (op == 1) { ;; add new entry
	int key = in_msg_body~load_uint(256);
	dic~udict_set(256, key, in_msg_body);

}
Сохраняем словарь
С помощью функции set_data() - запишем ячейку с hashmap постоянные данные.

if (op == 1) { ;; add new entry
	int key = in_msg_body~load_uint(256);
	dic~udict_set(256, key, in_msg_body);
	set_data(dic);

}
Завершаем выполнение функции
Здесь все просто, оператор return нам в помощь.

if (op == 1) { ;; add new entry
	int key = in_msg_body~load_uint(256);
	dic~udict_set(256, key, in_msg_body);
	set_data(dic);
	return ();
}
op = 2
Здесь наша задача удалить из своих данных все устаревшие записи (с valid_until < now()). Для того, чтобы "пройти" по hashmap будем использовать цикл. В FunC есть три цикла: repeat,until,while.

Так как мы уже вычитали op и query_id, проверим здесь, что в слайсе in_msg_body ничего нет с помощью end_parse()

end_parse() - Проверяет, является ли слайс пустым. Если нет, выдает исключение

if (op == 2) {
	in_msg_body.end_parse();
}
Для нашего случая воспользуемся циклом: until.

if (op == 2) {
	do {

	} until ();
}
Чтобы на каждом шаге проверять условие valid_until < now()), нам необходимо получать некий минимальный ключ нашего hashmap. Для этого в стандартной библиотеке FunC есть функция udict_get_next?.

udict_get_next?  - вычисляет минимальный ключ k в dict словаря, который больше, чем некоторое заданное значение, и возвращает k, связанное значение и флаг, указывающий на успех. Если словарь пуст, возвращает (null, null, 0).

Соответственно зададим перед циклом значение от, которого будем брать минимальный ключ, а в самом цикле будем использовать флаг, указывающий на успех.

if (op == 2) {
	int key = -1;
	do {
		(key, slice cs, int f) = dic.udict_get_next?(256, key);

	} until (~ f);
}
Теперь с помощью условного оператора будем проверять условие valid_until < now()). Значение valid_until вычитаем из slice cs.

if (op == 2) {
	int key = -1;
	do {
		(key, slice cs, int f) = dic.udict_get_next?(256, key);
		if (f) {
			int valid_until = cs~load_uint(64);
			if (valid_until < now()) {
					;; здесь будем удалять
			}
		}
	} until (~ f);
}
Удалять из hashmap будем используя udict_delete?.

udict_delete? - удаляет индекс с ключом k из словаря dict. Если ключ присутствует, возвращает модифицированный словарь (hashmap) и флаг успеха -1. В противном случае возвращает исходный словарь dict и 0.

Получаем:

if (op == 2) {
	int key = -1;
	do {
		(key, slice cs, int f) = dic.udict_get_next?(256, key);
		if (f) {
			int valid_until = cs~load_uint(64);
			if (valid_until < now()) {
				dic~udict_delete?(256, key);
			}
		}
	} until (~ f);

}
Сохраняем словарь
Используя dict_empty? проверим стал ли пустым hashmap после наших манипуляций в цикле.

Если значения есть, сохраняем в постоянные данные наш hashmap. Если нет, то положим туда пустую ячейку, с помощью комбинации функций begin_cell().end_cell()

if (dic.dict_empty?()) {
		set_data(begin_cell().end_cell());
	} else {
		set_data(dic);
	}
Завершаем выполнение функции
Здесь все просто, оператор return нам в помощь. Итоговый код op=2

if (op == 2) {
	int key = -1;
	do {
		(key, slice cs, int f) = dic.udict_get_next?(256, key);
		if (f) {
			int valid_until = cs~load_uint(64);
			if (valid_until < now()) {
				dic~udict_delete?(256, key);
			}
		}
	} until (~ f);

	if (dic.dict_empty?()) {
		set_data(begin_cell().end_cell());
	} else {
		set_data(dic);
	}

	return ();
}
Get функция
Метод get_key по ключу должен вернуть valid_until и слайс с данными по этому ключу. Соответственно по заданию нам надо:

взять данные из постоянных данных
найти данные по ключу
вернуть ошибку если данных нет
вычитать valid_until
вернуть данные
Берем постоянные данные контракта
Для загрузки данных напишем отдельную функцию load_data(), которая будет проверить есть ли данные и возвращать либо пустой словарь new_dict(), либо постоянные данные. Проверять будем с slice_bits() - которое возвращает количество битов данных в слайсе.

cell load_data() {
	cell data = get_data();
	slice ds = data.begin_parse();
	if (ds.slice_bits() == 0) {
		return new_dict();
	} else {
		return data;
	}
}
Теперь вызовем функцию в get методе.

(int, slice) get_key(int key) method_id {
	cell dic = load_data();

}
Ищем данные по ключу
Для поиска данных по ключу возьмем функцию udict_get?

udict_get? - ищет индекс ключа в словаре dict В случае успеха возвращает значение, найденное в виде слайса, вместе с флагом -1, указывающим на успех. В случае неудачи возвращает (null, 0).

Получим:

(int, slice) get_key(int key) method_id {
	cell dic = load_data();
	(slice payload, int success) = dic.udict_get?(256, key);

}
Возвращаем ошибку если данных нет
Функция udict_get? возвращает удобный флаг, который мы поместили в success. Используя throw_unless вернем исключение.

(int, slice) get_key(int key) method_id {
	cell dic = load_data();
	(slice payload, int success) = dic.udict_get?(256, key);
	throw_unless(98, success);

}
Вычитаем valid_until и вернем данные
Здесь все просто, из переменной payload вычитаем valid_until и вернем обе переменные.

(int, slice) get_key(int key) method_id {
	cell dic = load_data();
	(slice payload, int success) = dic.udict_get?(256, key);
	throw_unless(98, success);

	int valid_until = payload~load_uint(64);
	return (valid_until, payload);
}
Обёртка на TypeScript
Для удобного взаимодействия с нашим смарт-контрактом, напишем обёртку на TypeScript. База для неё уже предоставляется от Blueprint.

Конфиг данных контракта
Откроем файл wrappers/Hashmap.ts (название файла может быть другим, смотря как вы создавали проект). Конфиг данных остаётся пустым, как и задумано.

export type HashmapConfig = {};

export function hashmapConfigToCell(config: HashmapConfig): Cell {
    return beginCell().endCell();
}
Теперь перейдём к классу Hashmap чтобы добавить методы для вызова нужных нам операций.

Метод для вызова op = 1
При вызове операции с кодом 1, в тело сообщения мы должны положить: op=1, query_id, ключ, valid_until и само значение. Назовём метод sendSet.

async sendSet(
    provider: ContractProvider,
    via: Sender,
    value: bigint,
    opts: {
        queryId: bigint;
        key: bigint;
        value: Slice;
        validUntil: bigint;
    }
) {
    await provider.internal(via, {
        value,
        sendMode: SendMode.PAY_GAS_SEPARATELY,
        body: beginCell()
            .storeUint(1, 32)
            .storeUint(opts.queryId, 64)
            .storeUint(opts.key, 256)
            .storeUint(opts.validUntil, 64)
            .storeSlice(opts.value)
            .endCell(),
    });
}
Метод для вызова op = 2
Эта операция не требует дополнительных данных кроме op=2 и query_id. Назовём метод sendClearOldValues.

async sendClearOldValues(
    provider: ContractProvider,
    via: Sender,
    value: bigint,
    opts: {
        queryId: bigint;
    }
) {
    await provider.internal(via, {
        value,
        sendMode: SendMode.PAY_GAS_SEPARATELY,
        body: beginCell().storeUint(2, 32).storeUint(opts.queryId, 64).endCell(),
    });
}
Метод для вызова геттера get_key
Этот метод будет немного сложнее чем тот, что мы уже писали в одном из первых уроков, потому что здесь должно возвращаться сразу два значения. Такой тип в TypeScript можно задать как массив [bigint, Slice]. А Promise<> нужен потому что функция асинхронная (ключевое слово async перед её названием).

Вызовем provider.get и стек результата положим в константу result. Затем оттуда мы можем читать полученные значения для возврата из функции. С первым значением всё просто - делаем readBigNumber() чтобы прочитать bigint (который в FunC был int). Но с вторым значением появляется проблема: в библиотеке не предусмотрен отдельный метод для считывания слайса (что-то вроде readSlice()). Поэтому придётся использовать peek() который считывает следующее значение, игнорируя его тип, и явно указать компилятору, что это TupleItemSlice, а затем получить из него само значение.

async getByKey(provider: ContractProvider, key: bigint): Promise<[bigint, Slice]> {
    const result = (await provider.get('get_key', [{ type: 'int', value: key }])).stack;
    return [result.readBigNumber(), (result.peek() as TupleItemSlice).cell.asSlice()];
}
Заключение
Хотел сказать отдельное спасибо, тем кто донатит для поддержки проекта, это очень мотивирует и помогает выпускать уроки быстрее. Если вы хотите помочь проекту(быстрее выпускать уроки, перевести это все на английский итд), внизу на главной странице, есть адреса для донатов.

Урок 8 Тесты на FunC для смарт-контракта c Hashmap
Введение
В этом уроке мы напишем тесты для смарт-контракта созданного в седьмом уроке в блокчейне TON и выполним их с помощью Blueprint.

Требования
Для прохождения данного урока вам достаточно установить Node.js. Желательно устанавливать одну из последних версий, например 18.

А также пройти седьмой урок.

Меняем beforeEach в тестах для упрощения
Откроем файл tests/Hashmap.spec.ts в котором будут находиться наши тесты и поменяем функцию beforeEach, которая выполняется перед каждым тестом.

Добавим в неё установку текущего времени (меняем значение blockchain.now). Помимо этого, после успешного деплоя контракта, сразу попробуем установить три тестовых значения в нашей хешмапе используя написанный ранее метод sendSet.

С этого момента, в начале каждого теста, время уже будет установлено на 500, а также три значения будут уже записаны (или не записаны в случае если смарт-контракт работает некорректно).

Получаем примерно такую функцию:

beforeEach(async () => {
    blockchain = await Blockchain.create();

    blockchain.now = 500;

    deployer = await blockchain.treasury('deployer');

    hashmap = blockchain.openContract(
        Hashmap.createFromConfig(
            {
                manager: deployer.address,
            },
            code
        )
    );

    const deployResult = await hashmap.sendDeploy(
        deployer.getSender(),
        toNano('0.01')
    );

    expect(deployResult.transactions).toHaveTransaction({
        from: deployer.address,
        to: hashmap.address,
        deploy: true,
    });

    await hashmap.sendSet(deployer.getSender(), toNano('0.05'), {
        queryId: 123n,
        key: 1n,
        validUntil: 1000n,
        value: beginCell().storeUint(123, 16).endCell().asSlice(),
    });

    await hashmap.sendSet(deployer.getSender(), toNano('0.05'), {
        queryId: 123n,
        key: 2n,
        validUntil: 2000n,
        value: beginCell().storeUint(234, 16).endCell().asSlice(),
    });

    await hashmap.sendSet(deployer.getSender(), toNano('0.05'), {
        queryId: 123n,
        key: 3n,
        validUntil: 3000n,
        value: beginCell().storeUint(345, 16).endCell().asSlice(),
    });
});
Тестируем запись и получение значений
Помним, что запись значений уже произошла в beforeEach, поэтому здесь нам остаётся лишь проверить, что значения действительно записались корректно.

Для этого используем написанный нами метод getByKey и сравниваем оба значения validUntil и value с ожидаемыми значениями (теми, которые мы записали в контракт).

Замечу, что для сравнения специфичных для TON типов (например Address или Slice), существуют отдельные мэтчеры. В этом случае нам пригодился toEqualSlice, который в тесте сравнивает на равенство два слайса.

Повторим эту процедуру для всех трёх записанных значений и тест готов.

it('should store and retrieve values', async () => {
    let [validUntil, value] = await hashmap.getByKey(1n);
    expect(validUntil).toEqual(1000n);
    expect(value).toEqualSlice(
        beginCell().storeUint(123, 16).endCell().asSlice()
    );

    [validUntil, value] = await hashmap.getByKey(2n);
    expect(validUntil).toEqual(2000n);
    expect(value).toEqualSlice(
        beginCell().storeUint(234, 16).endCell().asSlice()
    );

    [validUntil, value] = await hashmap.getByKey(3n);
    expect(validUntil).toEqual(3000n);
    expect(value).toEqualSlice(
        beginCell().storeUint(345, 16).endCell().asSlice()
    );
});
Тестируем наличие ошибки при не существующем ключе
Гет-методы, как и external сообщения, при неуспешном выполнении выбрасывают ошибку в TypeScript программе. Поэтому здесь нам нужно проверить, что вызов getByKey(123n) завершится с ошибкой. Так как этот метод асинхронный (вызывается с await), этот самый await следует вставить перед expect().

Наличие ошибки при вызове функции можно проверить через .rejects.toThrow().

it('should throw on not found key', async () => {
    await expect(hashmap.getByKey(123n)).rejects.toThrow();
});
Тестируем очистку старых значений
В этом тесте нам пригодится возможность менять значение текущего времени blockchain.now.

Для начала, попробуем вызвать очистку значений, не меняя время. В таком случае, ключ 1 должен успешно найтись.

await hashmap.sendClearOldValues(deployer.getSender(), toNano('0.05'), {
    queryId: 123n,
});

let [validUntil, value] = await hashmap.getByKey(1n);
expect(validUntil).toEqual(1000n);
expect(value).toEqualSlice(beginCell().storeUint(123, 16).endCell().asSlice());
Далее, выставим время на 1001. Так как validUntil у первого ключа равен 1000, после очистки, этот ключ должен пропасть. При этом все оставшиеся ключи должны остаться в контракте и никак не поменяться.

blockchain.now = 1001;

await hashmap.sendClearOldValues(deployer.getSender(), toNano('0.05'), {
    queryId: 123n,
});

await expect(hashmap.getByKey(1n)).rejects.toThrow();

[validUntil, value] = await hashmap.getByKey(2n);
expect(validUntil).toEqual(2000n);
expect(value).toEqualSlice(beginCell().storeUint(234, 16).endCell().asSlice());

[validUntil, value] = await hashmap.getByKey(3n);
expect(validUntil).toEqual(3000n);
expect(value).toEqualSlice(beginCell().storeUint(345, 16).endCell().asSlice());
И наконец, выставим время на 3001, чтобы после очистки пропали все ключи. Проверять наличие первого ключа уже не имеет смысла, так как мы проверили это выше.

blockchain.now = 3001;

await hashmap.sendClearOldValues(deployer.getSender(), toNano('0.05'), {
    queryId: 123n,
});

await expect(hashmap.getByKey(2n)).rejects.toThrow();
await expect(hashmap.getByKey(3n)).rejects.toThrow();
Весь код этого теста:

it('should clear old values', async () => {
    await hashmap.sendClearOldValues(deployer.getSender(), toNano('0.05'), {
        queryId: 123n,
    });

    let [validUntil, value] = await hashmap.getByKey(1n);
    expect(validUntil).toEqual(1000n);
    expect(value).toEqualSlice(
        beginCell().storeUint(123, 16).endCell().asSlice()
    );

    blockchain.now = 1001;

    await hashmap.sendClearOldValues(deployer.getSender(), toNano('0.05'), {
        queryId: 123n,
    });

    await expect(hashmap.getByKey(1n)).rejects.toThrow();

    [validUntil, value] = await hashmap.getByKey(2n);
    expect(validUntil).toEqual(2000n);
    expect(value).toEqualSlice(
        beginCell().storeUint(234, 16).endCell().asSlice()
    );

    [validUntil, value] = await hashmap.getByKey(3n);
    expect(validUntil).toEqual(3000n);
    expect(value).toEqualSlice(
        beginCell().storeUint(345, 16).endCell().asSlice()
    );

    blockchain.now = 3001;

    await hashmap.sendClearOldValues(deployer.getSender(), toNano('0.05'), {
        queryId: 123n,
    });

    await expect(hashmap.getByKey(2n)).rejects.toThrow();
    await expect(hashmap.getByKey(3n)).rejects.toThrow();
});
Тестируем ошибку при ненайденном опкоде
Для этого воспользуемся методом send у deployer для отправки произвольного сообщения. Отправим, например, opcode = 123 и query_id = 123.

Такая транзакция должна закончиться с exitCode = 12, как мы и прописывали в контракте. Подобные проверки мы уже умеем делать.

it('should throw on wrong opcode', async () => {
    const result = await deployer.send({
        to: hashmap.address,
        value: toNano('0.05'),
        body: beginCell().storeUint(123, 32).storeUint(123, 64).endCell(),
    });
    expect(result.transactions).toHaveTransaction({
        from: deployer.address,
        to: hashmap.address,
        exitCode: 12,
    });
});
Тестируем ошибку при некорректном запросе
Как мы помним, op = 2 в нашем контракте предусматривает ошибку при наличии лишних данных в body сообщения. Это обеспечивается вызовом end_parse().

Для проверки этой ошибки, как и в прошлом тесте, воспользуемся методом send и отправим сообщение с опкодом = 2, но в конец тела добавим так же лишние данные.

Такая транзакция должна закончиться неуспешно, то есть в мэтчере toHaveTransaction добавим флаг success: false.

it('should throw on bad query', async () => {
    const result = await deployer.send({
        to: hashmap.address,
        value: toNano('0.05'),
        body: beginCell()
            .storeUint(2, 32)
            .storeUint(123, 64)
            .storeStringTail('This string should not be here!')
            .endCell(),
    });
    expect(result.transactions).toHaveTransaction({
        from: deployer.address,
        to: hashmap.address,
        success: false,
    });
});
Запускаем тесты
Запустим тесты командой npx blueprint test и мы должны увидеть следующее:

 PASS  tests/Hashmap.spec.ts
  Hashmap
    ✓ should store and retrieve values (173 ms)
    ✓ should throw on not found key (80 ms)
    ✓ should clear old values (95 ms)
    ✓ should throw on wrong opcode (73 ms)
    ✓ should throw on bad query (129 ms)
Если какие то тесты у вас не прошли, просмотрите код и текст этого урока ещё раз. Также сверьте свой код смарт-контракта с кодом из предыдущего урока.

Заключение
Хотел сказать отдельное спасибо, тем кто донатит для поддержки проекта, это очень мотивирует и помогает выпускать уроки быстрее. Если вы хотите помочь проекту(быстрее выпускать уроки, перевести это все на английский итд), внизу на главной странице, есть адреса для донатов.