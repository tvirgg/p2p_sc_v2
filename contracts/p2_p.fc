    #include "imports/stdlib.fc";

    const int op_create_deal = 1;
    const int op_resolve_deal = 2;
    const int op_refund_unknown = 3;
    const int op_withdraw_commissions = 4;
    const int op_fund_deal = 5;
    const int COMMISSION_WITH_MEMO = 3;
    const int COMMISSION_NO_MEMO = 3;

    int equal_slice_bits(slice a, slice b) asm "SDEQ";

() send_transfer(slice dest, int grams) impure inline {
    ~strdump("========== SEND_TRANSFER START ==========");
    ~strdump("–û—Ç–ø—Ä–∞–≤–∫–∞ —Å—Ä–µ–¥—Å—Ç–≤ –ø–æ–ª—É—á–∞—Ç–µ–ª—é");
    ~strdump("–ê–¥—Ä–µ—Å –ø–æ–ª—É—á–∞—Ç–µ–ª—è (dest):");
    ~dump(dest);
    ~strdump("–°—É–º–º–∞ –ø–µ—Ä–µ–≤–æ–¥–∞ (grams):");
    ~dump(grams);
    
    ;; –ü—Ä–æ—Å—Ç–∞—è –æ—Ç–ø—Ä–∞–≤–∫–∞ –º–æ–Ω–µ—Ç, —Å–∞–º—ã–π –±–∞–∑–æ–≤—ã–π –≤–∞—Ä–∏–∞–Ω—Ç
    var msg = begin_cell()
        .store_uint(0x18, 6)             ;; 0x18 = 011000 (bouncing internal message)
        .store_slice(dest)               ;; –∞–¥—Ä–µ—Å –ø–æ–ª—É—á–∞—Ç–µ–ª—è
        .store_coins(grams)              ;; —Å—É–º–º–∞ –ø–µ—Ä–µ–≤–æ–¥–∞
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1) ;; –ø—É—Å—Ç–æ–µ —Ç–µ–ª–æ (–Ω–µ—Ç initialize bit + body)
        .end_cell();

    ~strdump("–°—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–æ —Å–æ–æ–±—â–µ–Ω–∏–µ:");
    ~dump(msg);
    
    ~strdump("–û—Ç–ø—Ä–∞–≤–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è (send_raw_message)...");
    send_raw_message(msg, 1);
    ~strdump("–°–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ —Å mode = 1 (—Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π —Ä–µ–∂–∏–º)");
    ~strdump("========== SEND_TRANSFER END ==========");
}

    () require_moderator(slice sender, slice moderator_address) impure inline {
        ~strdump(">> REQUIRE_MODERATOR CALL");
        ~dump(moderator_address);
        ~dump(sender);
        if (equal_slice_bits(sender, moderator_address) == 0) {
            ~strdump(">> ACCESS FORBIDDEN");
            ~dump(sender);
            throw(999);
        }
    }
    (int, cell, cell, cell, slice, int) load_data() impure {
        cell data = get_data();
        if (cell_null?(data)) {
            return (0, new_dict(), new_dict(), new_dict(), null(), 0);
        }
        slice ds = data.begin_parse();
        if (slice_empty?(ds)) {
            return (0, new_dict(), new_dict(), new_dict(), null(), 0);
        }
        int deals_counter = ds~load_uint(32);
        cell deals_dict = ds~load_dict();
        cell memo_map = ds~load_dict();
        cell unknown_funds = ds~load_dict();
        slice moderator_address = null();
        
        ;; Always try to load moderator address if we have data
        if (~ ds.slice_empty?()) {
            moderator_address = ds~load_msg_addr();
        }
        
        int commissions_pool = 0;
        if (~ ds.slice_empty?()) {
            commissions_pool = ds~load_uint(32);
        }
        
        return (deals_counter, deals_dict, memo_map, unknown_funds, moderator_address, commissions_pool);
    }

    () save_data(int dc, cell dd, cell mm, cell uf, slice ma, int cp) impure {
        ;; Explicitly create the cell with all data
        cell data_cell = begin_cell()
                .store_uint(dc, 32)  ;; Store deal counter
                .store_dict(dd)      ;; Store deals dictionary
                .store_dict(mm)      ;; Store memo map
                .store_dict(uf)      ;; Store unknown funds
                .store_slice(ma)     ;; Store moderator address
                .store_uint(cp, 32)  ;; Store commissions pool
            .end_cell();
        
        ;; Set the data cell as the persistent storage
        set_data(data_cell);
    }

    () recv_external(slice in_msg_cell) impure {
        accept_message(); ;; üîß –û–±—è–∑–∞—Ç–µ–ª—å–Ω–æ –¥–ª—è –∑–∞–ø–∏—Å–∏ —Å–æ—Å—Ç–æ—è–Ω–∏—è!
        ~strdump(">> EXTERNAL START");
        var (dc, dd, mm, uf, ma, cp) = load_data();
        slice cs = in_msg_cell;
        int op = cs~load_uint(32);
        slice sender = cs~load_msg_addr();
        require_moderator(sender, ma);
        ~strdump("in_msg_cell:");
        ~dump(in_msg_cell);
        
        ;;slice cs = in_msg_cell.begin_parse();
        
        if (op == op_create_deal) {
            slice s = cs~load_msg_addr();
            slice b = cs~load_msg_addr();
            int a = cs~load_coins();
            cell m = cs~load_ref();
            int mh = cell_hash(m);
            var (_, f) = mm.udict_get?(256, mh);
            throw_if(100, f);
            cell d = begin_cell()
                .store_slice(s)
                .store_slice(b)
                .store_coins(a)
                .store_uint(0, 1)
                .end_cell();
            int id = dc;
            dc = dc + 1;  ;; Changed from dc += 1 to dc = dc + 1
            dd~udict_set_ref(32, id, d);
            mm~udict_set(
                256,
                mh,
                begin_cell().store_uint(id, 32).end_cell().begin_parse()
            );
            
            ;; Save the updated data immediately
            save_data(dc, dd, mm, uf, ma, cp);
            
            ;; Return early to avoid saving data again at the end of the function
            return ();
        } elseif (op == op_resolve_deal) {
            ~strdump("resolve_deal: –ù–∞—á–∞–ª–æ –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è");
            
            cell m = cs~load_ref();
            ~strdump("resolve_deal: –ü–æ–ª—É—á–µ–Ω cell m:");
            ~dump(m);
            
            int x = cs~load_uint(1);
            ~strdump("resolve_deal: –§–ª–∞–≥ —É—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è (x):");
            ~dump(x);
            
            int mh = cell_hash(m);
            ~strdump("resolve_deal: –•—ç—à cell m (mh):");
            ~dump(mh);
            
            var (dslice, f) = mm.udict_get?(256, mh);
            throw_unless(110, f);
            ~strdump("resolve_deal: dslice –∏–∑ mm –¥–ª—è hash mh:");
            ~dump(dslice);
            
            int id = dslice~load_uint(32);
            ~strdump("resolve_deal: –ò–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä —Å–¥–µ–ª–∫–∏ (id):");
            ~dump(id);
            
            (cell c, int found) = dd.udict_get_ref?(32, id);
            throw_unless(140, found);
            ~strdump("resolve_deal: –ü–æ–ª—É—á–µ–Ω cell c (—Å–¥–µ–ª–∫–∞):");
            ~dump(c);
            
            slice d2 = c.begin_parse();
            slice s = d2~load_msg_addr();
            ~strdump("resolve_deal: –ê–¥—Ä–µ—Å –æ—Ç–ø—Ä–∞–≤–∏—Ç–µ–ª—è (s) —Å–¥–µ–ª–∫–∏:");
            ~dump(s);
            
            slice b = d2~load_msg_addr();
            ~strdump("resolve_deal: –ê–¥—Ä–µ—Å –ø–æ–ª—É—á–∞—Ç–µ–ª—è (b) —Å–¥–µ–ª–∫–∏:");
            ~dump(b);
            
            int amt = d2~load_coins();
            ~strdump("resolve_deal: –°—É–º–º–∞ —Å–¥–µ–ª–∫–∏ (amt):");
            ~dump(amt);
            
            int funded = d2~load_uint(1);
            ~strdump("resolve_deal: –§–ª–∞–≥ –æ–ø–ª–∞—Ç—ã —Å–¥–µ–ª–∫–∏ (funded):");
            ~dump(funded);
            
            throw_unless(111, funded);
            ~strdump("resolve_deal: –ó–Ω–∞—á–µ–Ω–∏–µ —Ñ–ª–∞–≥–∞ x –ø–æ—Å–ª–µ –∑–∞–≥—Ä—É–∑–∫–∏:");
            ~dump(x);
            
            if (x == 1) {
                ~strdump("resolve_deal: x == 1, –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å—Ä–µ–¥—Å—Ç–≤–∞ –ü–†–û–î–ê–í–¶–£");
                send_transfer(s, amt);
                ~strdump("–û—Ç–ø—Ä–∞–≤–∫–∞ S");
            } else {
                ~strdump("resolve_deal: x == 0, –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å—Ä–µ–¥—Å—Ç–≤–∞ –ü–û–ö–£–ü–ê–¢–ï–õ–Æ");
                send_transfer(b, amt);
                ~strdump("–û—Ç–ø—Ä–∞–≤–∫–∞ B");
            }
            dd~udict_delete?(32, id);
            mm~udict_delete?(256, mh);
            ~strdump("—É–¥–∞–ª–∏—Ç—å dd mm");
            ;; Save the updated data immediately
            save_data(dc, dd, mm, uf, ma, cp);
            ~strdump("save data");
            ;; Return early to avoid saving data again at the end of the function
            return ();
        } elseif (op == op_refund_unknown) {
            int k = cs~load_uint(32);
            (cell c, int f) = uf.udict_get_ref?(32, k);
            throw_unless(120, f);
            slice ds2 = c.begin_parse();
            slice orig = ds2~load_msg_addr();
            int val = ds2~load_uint(128);
            send_transfer(orig, val);
            uf~udict_delete?(32, k);
            
            ;; Save the updated data immediately
            save_data(dc, dd, mm, uf, ma, cp);
            
            ;; Return early to avoid saving data again at the end of the function
            return ();
        } elseif (op == op_withdraw_commissions) {
            ;;int amt = cs~load_coins();
            ;;–∂–∂throw_if(160, amt > cp);
            ;;cp -= amt;
            send_transfer(sender, cp);
            cp -= cp;
            ;; Save the updated data immediately
            save_data(dc, dd, mm, uf, ma, cp);
            
            ;; Return early to avoid saving data again at the end of the function
            return ();
        }
        save_data(dc, dd, mm, uf, ma, cp);
    }

    () recv_internal(int msg_value, cell in_msg_full, slice in_msg_body) impure {
        accept_message();
        ~strdump(">> INTERNAL START");
        var (dc, dd, mm, uf, ma, cp) = load_data();
        slice msg_slice = in_msg_full.begin_parse();
        int flags = msg_slice~load_uint(4);
        slice sender = msg_slice~load_msg_addr();
        

        

        ;; –¢–µ–ø–µ—Ä—å in_msg_body ‚Äî —ç—Ç–æ —É–∂–µ body (cs)
        slice cs = in_msg_body;

        if (cs.slice_bits() >= 32) {
            int op = cs~load_uint(32);
            ~strdump("OP CODE:");
            ~dump(op);

            if (op == op_create_deal) {
                require_moderator(sender, ma);
                int query_id = cs~load_uint(64);
                slice s = cs~load_msg_addr();
                slice b = cs~load_msg_addr();

                ~strdump(">> CREATE_DEAL: –ê–¥—Ä–µ—Å –ø—Ä–æ–¥–∞–≤—Ü–∞ (s):");
                ~dump(s);
                ~strdump(">> CREATE_DEAL: –ê–¥—Ä–µ—Å –ø–æ–∫—É–ø–∞—Ç–µ–ª—è (b):");
                ~dump(b);

                int a = cs~load_coins();
                cell m = cs~load_ref();
                int mh = cell_hash(m);

                var (_, f) = mm.udict_get?(256, mh);
                throw_if(100, f);

                cell d = begin_cell()
                    .store_slice(s)
                    .store_slice(b)
                    .store_coins(a)
                    .store_uint(0, 1)
                    .end_cell();

                int id = dc;
                dc = dc + 1;

                dd~udict_set_ref(32, id, d);
                mm~udict_set(
                    256,
                    mh,
                    begin_cell().store_uint(id, 32).end_cell().begin_parse()
                );

                save_data(dc, dd, mm, uf, ma, cp);
                ~strdump("<<< CREATE COMPLETE");
                return ();
            } elseif (op == op_fund_deal) {
                ~strdump(">>> FUND_DEAL START");

                int query_id = cs~load_uint(64);
                cell m = cs~load_ref();
                int mh = cell_hash(m);

                var (dslice, f) = mm.udict_get?(256, mh);
                throw_unless(130, f);
                int id = dslice~load_uint(32);

                (cell c2, int found) = dd.udict_get_ref?(32, id);
                throw_unless(140, found);

                slice d2 = c2.begin_parse();
                slice s = d2~load_msg_addr();
                slice b = d2~load_msg_addr();
                int amt = d2~load_coins();
                int funded = d2~load_uint(1);

                throw_if(131, funded);
                throw_if(132, msg_value < amt);

                int comm = (amt * COMMISSION_WITH_MEMO) / 100;
                throw_if(132, msg_value < amt + comm);

                cp += comm;

                cell nd = begin_cell()
                    .store_slice(s)
                    .store_slice(b)
                    .store_coins(amt)
                    .store_uint(1, 1)
                    .end_cell();

                dd~udict_set_ref(32, id, nd);

                save_data(dc, dd, mm, uf, ma, cp);
                ~strdump("<<< FUND_DEAL COMPLETE");
                return ();
            }
        }

        save_data(dc, dd, mm, uf, ma, cp);
    }

    (int, int) get_deal_info(int deal_id) method_id {
        var (dc, dd, mm, uf, ma, cp) = load_data();
        (cell c, int found) = dd.udict_get_ref?(32, deal_id);
        if (found == 0) {
            ~strdump("NOT FOUND");
            return (0, 0);
        }
        ~strdump("FOUND!");
        
        slice d2 = c.begin_parse();
        d2~load_msg_addr();  ;; Skip seller address
        d2~load_msg_addr();  ;; Skip buyer address
        int amt = d2~load_coins();  ;; Read amount
        int f = d2~load_uint(1);    ;; Read funded status
        
        return (amt, f);
    }

    int get_deal_counter() method_id {
        var (dc, dd, mm, uf, ma, cp) = load_data();
        return dc;
    }

    ;; Debug function to dump a deal
    (slice, slice, int, int) debug_get_deal(int deal_id) method_id {
        var (dc, dd, mm, uf, ma, cp) = load_data();
        (cell c, int found) = dd.udict_get_ref?(32, deal_id);
        if (found == 0) {
            return (null(), null(), 0, 0);
        }
        
        slice d2 = c.begin_parse();
        slice seller = d2~load_msg_addr();
        slice buyer = d2~load_msg_addr();
        int amt = d2~load_coins();
        int f = d2~load_uint(1);
        
        return (seller, buyer, amt, f);
    }

    ;; Debug function to get the moderator address
    slice get_moderator() method_id {
        var (dc, dd, mm, uf, ma, cp) = load_data();
        return ma;
    }

    ;; Debug function to dump all contract data
    (int, int, slice) debug_get_contract_data() method_id {
        var (dc, dd, mm, uf, ma, cp) = load_data();
        return (dc, cp, ma);
    }

    ;; Debug function to check if a deal exists
    int debug_deal_exists(int deal_id) method_id {
        var (dc, dd, mm, uf, ma, cp) = load_data();
        (_, int found) = dd.udict_get_ref?(32, deal_id);
        return found;
    }

    ;; Debug function to get the raw data cell
    cell debug_get_raw_data() method_id {
        return get_data();
    }
