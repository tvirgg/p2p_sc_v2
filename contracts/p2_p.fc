    #include "imports/stdlib.fc";

    const int op_create_deal = 1;
    const int op_resolve_deal = 2;
    const int op_refund_unknown = 3;
    const int op_withdraw_commissions = 4;
    const int op_fund_deal = 5;
    const int COMMISSION_WITH_MEMO = 3;
    const int COMMISSION_NO_MEMO = 3;

    int equal_slice_bits(slice a, slice b) asm "SDEQ";

    () send_transfer(slice dest, int grams) impure inline {
        var msg = begin_cell()
            .store_uint(0x10, 6)
            .store_slice(dest)
            .store_coins(grams)
            .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
            .end_cell();
        send_raw_message(msg, 1);
    }

    ;;() require_moderator(slice sender, slice moderator_address) impure inline {
    ;;    throw_unless(999, equal_slice_bits(sender, moderator_address));
    ;;}
    (int, cell, cell, cell, slice, int) load_data() impure {
        cell data = get_data();
        if (cell_null?(data)) {
            return (0, new_dict(), new_dict(), new_dict(), null(), 0);
        }
        slice ds = data.begin_parse();
        if (slice_empty?(ds)) {
            return (0, new_dict(), new_dict(), new_dict(), null(), 0);
        }
        int deals_counter = ds~load_uint(32);
        cell deals_dict = ds~load_dict();
        cell memo_map = ds~load_dict();
        cell unknown_funds = ds~load_dict();
        slice moderator_address = null();
        
        ;; Always try to load moderator address if we have data
        if (~ ds.slice_empty?()) {
            moderator_address = ds~load_msg_addr();
        }
        
        int commissions_pool = 0;
        if (~ ds.slice_empty?()) {
            commissions_pool = ds~load_uint(32);
        }
        
        return (deals_counter, deals_dict, memo_map, unknown_funds, moderator_address, commissions_pool);
    }

    () save_data(int dc, cell dd, cell mm, cell uf, slice ma, int cp) impure {
        ;; Explicitly create the cell with all data
        cell data_cell = begin_cell()
                .store_uint(dc, 32)  ;; Store deal counter
                .store_dict(dd)      ;; Store deals dictionary
                .store_dict(mm)      ;; Store memo map
                .store_dict(uf)      ;; Store unknown funds
                .store_slice(ma)     ;; Store moderator address
                .store_uint(cp, 32)  ;; Store commissions pool
            .end_cell();
        
        ;; Set the data cell as the persistent storage
        set_data(data_cell);
    }

    () recv_external(int msg_value, cell in_msg_cell) impure {
        accept_message(); ;; 🔧 Обязательно для записи состояния!
        ~dump("HEHEHEBOYEXT");
        var (dc, dd, mm, uf, ma, cp) = load_data();
        slice cs = in_msg_cell.begin_parse();
        int op = cs~load_uint(32);
        slice sender = cs~load_msg_addr();
        if (op == op_create_deal) {
            slice s = cs~load_msg_addr();
            slice b = cs~load_msg_addr();
            int a = cs~load_coins();
            cell m = cs~load_ref();
            int mh = cell_hash(m);
            var (_, f) = mm.udict_get?(256, mh);
            throw_if(100, f);
            cell d = begin_cell()
                .store_slice(s)
                .store_slice(b)
                .store_coins(a)
                .store_uint(0, 1)
                .end_cell();
            int id = dc;
            dc = dc + 1;  ;; Changed from dc += 1 to dc = dc + 1
            dd~udict_set_ref(32, id, d);
            mm~udict_set(
                256,
                mh,
                begin_cell().store_uint(id, 32).end_cell().begin_parse()
            );
            
            ;; Save the updated data immediately
            save_data(dc, dd, mm, uf, ma, cp);
            
            ;; Return early to avoid saving data again at the end of the function
            return ();
        } elseif (op == op_resolve_deal) {
            cell m = cs~load_ref();
            int x = cs~load_uint(1);
            int mh = cell_hash(m);
            var (dslice, f) = mm.udict_get?(256, mh);
            throw_unless(110, f);
            int id = dslice~load_uint(32);
            (cell c, int found) = dd.udict_get_ref?(32, id);
            throw_unless(140, found);
            slice d2 = c.begin_parse();
            slice s = d2~load_msg_addr();
            slice b = d2~load_msg_addr();
            int amt = d2~load_coins();
            int funded = d2~load_uint(1);
            throw_unless(111, funded);
            if (x == 1) {
                send_transfer(s, amt);
            } else {
                send_transfer(b, amt);
            }
            dd~udict_delete?(32, id);
            mm~udict_delete?(256, mh);
            
            ;; Save the updated data immediately
            save_data(dc, dd, mm, uf, ma, cp);
            
            ;; Return early to avoid saving data again at the end of the function
            return ();
        } elseif (op == op_refund_unknown) {
            int k = cs~load_uint(32);
            (cell c, int f) = uf.udict_get_ref?(32, k);
            throw_unless(120, f);
            slice ds2 = c.begin_parse();
            slice orig = ds2~load_msg_addr();
            int val = ds2~load_uint(128);
            send_transfer(orig, val);
            uf~udict_delete?(32, k);
            
            ;; Save the updated data immediately
            save_data(dc, dd, mm, uf, ma, cp);
            
            ;; Return early to avoid saving data again at the end of the function
            return ();
        } elseif (op == op_withdraw_commissions) {
            int amt = cs~load_coins();
            throw_if(160, amt > cp);
            cp -= amt;
            send_transfer(sender, amt);
            
            ;; Save the updated data immediately
            save_data(dc, dd, mm, uf, ma, cp);
            
            ;; Return early to avoid saving data again at the end of the function
            return ();
        }
        save_data(dc, dd, mm, uf, ma, cp);
    }

    () recv_internal(int msg_value, cell in_msg_full) impure {
        accept_message();
        ~strdump("HEHEHEBOYINT");
        var (dc, dd, mm, uf, ma, cp) = load_data();
        slice cs = in_msg_full.begin_parse();

        ;; Пропускаем заголовок внутреннего сообщения:
        cs~load_uint(4);  
        slice sender = cs~load_msg_addr();
        int forwardValue = cs~load_coins(); 
        cs~load_uint(1 + 4 + 4 + 64 + 32 + 1 + 1);

        if (cs.slice_bits() >= 32) {
            int op = cs~load_uint(32);
            
            if (op == op_create_deal) {
                ;; Check that sender is the moderator
                ;; require_moderator(sender, ma);
                
                slice s = cs~load_msg_addr();
                slice b = cs~load_msg_addr();
                int a = cs~load_coins();
                cell m = cs~load_ref();
                int mh = cell_hash(m);
                var (_, f) = mm.udict_get?(256, mh);
                throw_if(100, f);
                
                ;; Create deal cell with amount and funded status
                cell d = begin_cell()
                    .store_slice(s)
                    .store_slice(b)
                    .store_coins(a)  ;; Store the amount
                    .store_uint(0, 1)  ;; Not funded yet
                    .end_cell();
                    
                ;; Increment counter and store deal
                int id = dc;
                dc = dc + 1;  ;; Increment the counter
                
                ;; Store the deal in the dictionary
                dd~udict_set_ref(32, id, d);
                
                ;; Store the mapping from memo hash to deal ID
                mm~udict_set(
                    256,
                    mh,
                    begin_cell().store_uint(id, 32).end_cell().begin_parse()
                );
                
                ;; Save the updated data immediately
                save_data(dc, dd, mm, uf, ma, cp);
                
                ;; Return early to avoid saving data again at the end of the function
                return ();
            } elseif (op == op_fund_deal) {
                cell m = cs~load_ref();
                int mh = cell_hash(m);
                var (dslice, f) = mm.udict_get?(256, mh);
                throw_unless(130, f);
                int id = dslice~load_uint(32);
                (cell c2, int found) = dd.udict_get_ref?(32, id);
                throw_unless(140, found);
                slice d2 = c2.begin_parse();
                slice s = d2~load_msg_addr();
                slice b = d2~load_msg_addr();
                int amt = d2~load_coins();
                int funded = d2~load_uint(1);
                throw_if(131, funded);
                throw_if(132, msg_value < amt);
                int comm = (amt * COMMISSION_WITH_MEMO) / 100;
                throw_if(132, msg_value < amt + comm);
                cp += comm;
                
                ;; Create new deal cell with funded=1
                cell nd = begin_cell()
                    .store_slice(s)
                    .store_slice(b)
                    .store_coins(amt)
                    .store_uint(1, 1)
                    .end_cell();
                    
                ;; Update the deal in the dictionary
                dd~udict_set_ref(32, id, nd);
                
                ;; Save the updated data immediately
                save_data(dc, dd, mm, uf, ma, cp);
                
                ;; Return early to avoid saving data again at the end of the function
                return ();
            }
        }
        save_data(dc, dd, mm, uf, ma, cp);
    }

    (int, int) get_deal_info(int deal_id) method_id {
        var (dc, dd, mm, uf, ma, cp) = load_data();
        (cell c, int found) = dd.udict_get_ref?(32, deal_id);
        if (found == 0) {
            return (0, 0);
        }
        
        slice d2 = c.begin_parse();
        d2~load_msg_addr();  ;; Skip seller address
        d2~load_msg_addr();  ;; Skip buyer address
        int amt = d2~load_coins();  ;; Read amount
        int f = d2~load_uint(1);    ;; Read funded status
        
        return (amt, f);
    }

    int get_deal_counter() method_id {
        var (dc, dd, mm, uf, ma, cp) = load_data();
        return dc;
    }

    ;; Debug function to dump a deal
    (slice, slice, int, int) debug_get_deal(int deal_id) method_id {
        var (dc, dd, mm, uf, ma, cp) = load_data();
        (cell c, int found) = dd.udict_get_ref?(32, deal_id);
        if (found == 0) {
            return (null(), null(), 0, 0);
        }
        
        slice d2 = c.begin_parse();
        slice seller = d2~load_msg_addr();
        slice buyer = d2~load_msg_addr();
        int amt = d2~load_coins();
        int f = d2~load_uint(1);
        
        return (seller, buyer, amt, f);
    }

    ;; Debug function to get the moderator address
    slice get_moderator() method_id {
        var (dc, dd, mm, uf, ma, cp) = load_data();
        return ma;
    }

    ;; Debug function to dump all contract data
    (int, int, slice) debug_get_contract_data() method_id {
        var (dc, dd, mm, uf, ma, cp) = load_data();
        return (dc, cp, ma);
    }

    ;; Debug function to check if a deal exists
    int debug_deal_exists(int deal_id) method_id {
        var (dc, dd, mm, uf, ma, cp) = load_data();
        (_, int found) = dd.udict_get_ref?(32, deal_id);
        return found;
    }

    ;; Debug function to get the raw data cell
    cell debug_get_raw_data() method_id {
        return get_data();
    }
