    #include "imports/stdlib.fc";

    const int op_create_deal = 1;
    const int op_resolve_deal = 2;
    const int op_refund_unknown = 3;
    const int op_withdraw_commissions = 4;
    const int op_fund_deal = 5;
    const int COMMISSION_WITH_MEMO = 3;
    const int COMMISSION_NO_MEMO = 3;

    int equal_slice_bits(slice a, slice b) asm "SDEQ";

() send_transfer(slice dest, int grams) impure inline {
    ~strdump("=== SEND_TRANSFER ===");
    ~dump(dest); ;; 🟡 логируем slice

    var msg = begin_cell()
        .store_uint(0x10, 6)
        .store_slice(dest)
        .store_coins(grams)
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .end_cell();

    ~strdump("=== RAW MSG TO SEND ===");
    ~dump(msg); ;; 🟡 логируем сообщение

    send_raw_message(msg, 1);
}

    ;;() require_moderator(slice sender, slice moderator_address) impure inline {
    ;;    throw_unless(999, equal_slice_bits(sender, moderator_address));
    ;;}
    (int, cell, cell, cell, slice, int) load_data() impure {
        cell data = get_data();
        if (cell_null?(data)) {
            return (0, new_dict(), new_dict(), new_dict(), null(), 0);
        }
        slice ds = data.begin_parse();
        if (slice_empty?(ds)) {
            return (0, new_dict(), new_dict(), new_dict(), null(), 0);
        }
        int deals_counter = ds~load_uint(32);
        cell deals_dict = ds~load_dict();
        cell memo_map = ds~load_dict();
        cell unknown_funds = ds~load_dict();
        slice moderator_address = null();
        
        ;; Always try to load moderator address if we have data
        if (~ ds.slice_empty?()) {
            moderator_address = ds~load_msg_addr();
        }
        
        int commissions_pool = 0;
        if (~ ds.slice_empty?()) {
            commissions_pool = ds~load_uint(32);
        }
        
        return (deals_counter, deals_dict, memo_map, unknown_funds, moderator_address, commissions_pool);
    }

    () save_data(int dc, cell dd, cell mm, cell uf, slice ma, int cp) impure {
        ;; Explicitly create the cell with all data
        cell data_cell = begin_cell()
                .store_uint(dc, 32)  ;; Store deal counter
                .store_dict(dd)      ;; Store deals dictionary
                .store_dict(mm)      ;; Store memo map
                .store_dict(uf)      ;; Store unknown funds
                .store_slice(ma)     ;; Store moderator address
                .store_uint(cp, 32)  ;; Store commissions pool
            .end_cell();
        
        ;; Set the data cell as the persistent storage
        set_data(data_cell);
    }

    () recv_external(slice in_msg_cell) impure {
        accept_message(); ;; 🔧 Обязательно для записи состояния!
        ~strdump("in_msg_cell:");
        ~dump(in_msg_cell);
        var (dc, dd, mm, uf, ma, cp) = load_data();
        ;;slice cs = in_msg_cell.begin_parse();
        slice cs = in_msg_cell;
        int op = cs~load_uint(32);
        slice sender = cs~load_msg_addr();
        if (op == op_create_deal) {
            slice s = cs~load_msg_addr();
            slice b = cs~load_msg_addr();
            int a = cs~load_coins();
            cell m = cs~load_ref();
            int mh = cell_hash(m);
            var (_, f) = mm.udict_get?(256, mh);
            throw_if(100, f);
            cell d = begin_cell()
                .store_slice(s)
                .store_slice(b)
                .store_coins(a)
                .store_uint(0, 1)
                .end_cell();
            int id = dc;
            dc = dc + 1;  ;; Changed from dc += 1 to dc = dc + 1
            dd~udict_set_ref(32, id, d);
            mm~udict_set(
                256,
                mh,
                begin_cell().store_uint(id, 32).end_cell().begin_parse()
            );
            
            ;; Save the updated data immediately
            save_data(dc, dd, mm, uf, ma, cp);
            
            ;; Return early to avoid saving data again at the end of the function
            return ();
        } elseif (op == op_resolve_deal) {
            ~strdump("resolve_deal: Начало обработки сообщения");
            
            cell m = cs~load_ref();
            ~strdump("resolve_deal: Получен cell m:");
            ~dump(m);
            
            int x = cs~load_uint(1);
            ~strdump("resolve_deal: Флаг утверждения (x):");
            ~dump(x);
            
            int mh = cell_hash(m);
            ~strdump("resolve_deal: Хэш cell m (mh):");
            ~dump(mh);
            
            var (dslice, f) = mm.udict_get?(256, mh);
            throw_unless(110, f);
            ~strdump("resolve_deal: dslice из mm для hash mh:");
            ~dump(dslice);
            
            int id = dslice~load_uint(32);
            ~strdump("resolve_deal: Идентификатор сделки (id):");
            ~dump(id);
            
            (cell c, int found) = dd.udict_get_ref?(32, id);
            throw_unless(140, found);
            ~strdump("resolve_deal: Получен cell c (сделка):");
            ~dump(c);
            
            slice d2 = c.begin_parse();
            slice s = d2~load_msg_addr();
            ~strdump("resolve_deal: Адрес отправителя (s) сделки:");
            ~dump(s);
            
            slice b = d2~load_msg_addr();
            ~strdump("resolve_deal: Адрес получателя (b) сделки:");
            ~dump(b);
            
            int amt = d2~load_coins();
            ~strdump("resolve_deal: Сумма сделки (amt):");
            ~dump(amt);
            
            int funded = d2~load_uint(1);
            ~strdump("resolve_deal: Флаг оплаты сделки (funded):");
            ~dump(funded);
            
            throw_unless(111, funded);
            if (x == 1) {
                send_transfer(s, amt);
                ~strdump("Отправка S");
            } else {
                send_transfer(b, amt);
                ~strdump("Отправка B");
            }
            dd~udict_delete?(32, id);
            mm~udict_delete?(256, mh);
            ~strdump("удалить dd mm");
            ;; Save the updated data immediately
            save_data(dc, dd, mm, uf, ma, cp);
            ~strdump("save data");
            ;; Return early to avoid saving data again at the end of the function
            return ();
        } elseif (op == op_refund_unknown) {
            int k = cs~load_uint(32);
            (cell c, int f) = uf.udict_get_ref?(32, k);
            throw_unless(120, f);
            slice ds2 = c.begin_parse();
            slice orig = ds2~load_msg_addr();
            int val = ds2~load_uint(128);
            send_transfer(orig, val);
            uf~udict_delete?(32, k);
            
            ;; Save the updated data immediately
            save_data(dc, dd, mm, uf, ma, cp);
            
            ;; Return early to avoid saving data again at the end of the function
            return ();
        } elseif (op == op_withdraw_commissions) {
            int amt = cs~load_coins();
            throw_if(160, amt > cp);
            cp -= amt;
            send_transfer(sender, amt);
            
            ;; Save the updated data immediately
            save_data(dc, dd, mm, uf, ma, cp);
            
            ;; Return early to avoid saving data again at the end of the function
            return ();
        }
        save_data(dc, dd, mm, uf, ma, cp);
    }

    () recv_internal(int msg_value, cell in_msg_full, slice in_msg_body) impure {
        accept_message();
        ~strdump(">> INTERNAL START");

        var (dc, dd, mm, uf, ma, cp) = load_data();

        ;; Теперь in_msg_body — это уже body (cs)
        slice cs = in_msg_body;

        if (cs.slice_bits() >= 32) {
            int op = cs~load_uint(32);
            ~strdump("OP CODE:");
            ~dump(op);

            if (op == op_create_deal) {
                int query_id = cs~load_uint(64);
                slice s = cs~load_msg_addr();
                slice b = cs~load_msg_addr();
                int a = cs~load_coins();
                cell m = cs~load_ref();
                int mh = cell_hash(m);

                var (_, f) = mm.udict_get?(256, mh);
                throw_if(100, f);

                cell d = begin_cell()
                    .store_slice(s)
                    .store_slice(b)
                    .store_coins(a)
                    .store_uint(0, 1)
                    .end_cell();

                int id = dc;
                dc = dc + 1;

                dd~udict_set_ref(32, id, d);
                mm~udict_set(
                    256,
                    mh,
                    begin_cell().store_uint(id, 32).end_cell().begin_parse()
                );

                save_data(dc, dd, mm, uf, ma, cp);
                ~strdump("<<< CREATE COMPLETE");
                return ();
            } elseif (op == op_fund_deal) {
                ~strdump(">>> FUND_DEAL START");

                int query_id = cs~load_uint(64);
                cell m = cs~load_ref();
                int mh = cell_hash(m);

                var (dslice, f) = mm.udict_get?(256, mh);
                throw_unless(130, f);
                int id = dslice~load_uint(32);

                (cell c2, int found) = dd.udict_get_ref?(32, id);
                throw_unless(140, found);

                slice d2 = c2.begin_parse();
                slice s = d2~load_msg_addr();
                slice b = d2~load_msg_addr();
                int amt = d2~load_coins();
                int funded = d2~load_uint(1);

                throw_if(131, funded);
                throw_if(132, msg_value < amt);

                int comm = (amt * COMMISSION_WITH_MEMO) / 100;
                throw_if(132, msg_value < amt + comm);

                cp += comm;

                cell nd = begin_cell()
                    .store_slice(s)
                    .store_slice(b)
                    .store_coins(amt)
                    .store_uint(1, 1)
                    .end_cell();

                dd~udict_set_ref(32, id, nd);

                save_data(dc, dd, mm, uf, ma, cp);
                ~strdump("<<< FUND_DEAL COMPLETE");
                return ();
            }
        }

        save_data(dc, dd, mm, uf, ma, cp);
    }

    (int, int) get_deal_info(int deal_id) method_id {
        var (dc, dd, mm, uf, ma, cp) = load_data();
        (cell c, int found) = dd.udict_get_ref?(32, deal_id);
        if (found == 0) {
            ~strdump("NOT FOUND");
            return (0, 0);
        }
        ~strdump("FOUND!");
        
        slice d2 = c.begin_parse();
        d2~load_msg_addr();  ;; Skip seller address
        d2~load_msg_addr();  ;; Skip buyer address
        int amt = d2~load_coins();  ;; Read amount
        int f = d2~load_uint(1);    ;; Read funded status
        
        return (amt, f);
    }

    int get_deal_counter() method_id {
        var (dc, dd, mm, uf, ma, cp) = load_data();
        return dc;
    }

    ;; Debug function to dump a deal
    (slice, slice, int, int) debug_get_deal(int deal_id) method_id {
        var (dc, dd, mm, uf, ma, cp) = load_data();
        (cell c, int found) = dd.udict_get_ref?(32, deal_id);
        if (found == 0) {
            return (null(), null(), 0, 0);
        }
        
        slice d2 = c.begin_parse();
        slice seller = d2~load_msg_addr();
        slice buyer = d2~load_msg_addr();
        int amt = d2~load_coins();
        int f = d2~load_uint(1);
        
        return (seller, buyer, amt, f);
    }

    ;; Debug function to get the moderator address
    slice get_moderator() method_id {
        var (dc, dd, mm, uf, ma, cp) = load_data();
        return ma;
    }

    ;; Debug function to dump all contract data
    (int, int, slice) debug_get_contract_data() method_id {
        var (dc, dd, mm, uf, ma, cp) = load_data();
        return (dc, cp, ma);
    }

    ;; Debug function to check if a deal exists
    int debug_deal_exists(int deal_id) method_id {
        var (dc, dd, mm, uf, ma, cp) = load_data();
        (_, int found) = dd.udict_get_ref?(32, deal_id);
        return found;
    }

    ;; Debug function to get the raw data cell
    cell debug_get_raw_data() method_id {
        return get_data();
    }
