    #include "imports/stdlib.fc";

    const int op_create_deal = 1;
    const int op_resolve_deal = 2;
    const int op_refund_unknown = 3;
    const int op_withdraw_commissions = 4;
    const int op_fund_deal = 5;
    const int COMMISSION_WITH_MEMO = 3;
    const int COMMISSION_NO_MEMO = 3;

    int equal_slice_bits(slice a, slice b) asm "SDEQ";

() send_transfer(slice dest, int grams) impure inline {
    ~strdump("========== SEND_TRANSFER START ==========");
    ~strdump("–û—Ç–ø—Ä–∞–≤–∫–∞ —Å—Ä–µ–¥—Å—Ç–≤ –ø–æ–ª—É—á–∞—Ç–µ–ª—é");
    ~strdump("–ê–¥—Ä–µ—Å –ø–æ–ª—É—á–∞—Ç–µ–ª—è (dest):");
    ~dump(dest);
    ~strdump("–°—É–º–º–∞ –ø–µ—Ä–µ–≤–æ–¥–∞ (grams):");
    ~dump(grams);
    
    ;; –ü—Ä–æ—Å—Ç–∞—è –æ—Ç–ø—Ä–∞–≤–∫–∞ –º–æ–Ω–µ—Ç, —Å–∞–º—ã–π –±–∞–∑–æ–≤—ã–π –≤–∞—Ä–∏–∞–Ω—Ç
    var msg = begin_cell()
        .store_uint(0x18, 6)             ;; 0x18 = 011000 (bouncing internal message)
        .store_slice(dest)               ;; –∞–¥—Ä–µ—Å –ø–æ–ª—É—á–∞—Ç–µ–ª—è
        .store_coins(grams)              ;; —Å—É–º–º–∞ –ø–µ—Ä–µ–≤–æ–¥–∞
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1) ;; –ø—É—Å—Ç–æ–µ —Ç–µ–ª–æ (–Ω–µ—Ç initialize bit + body)
        .end_cell();

    ~strdump("–°—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–æ —Å–æ–æ–±—â–µ–Ω–∏–µ:");
    ~dump(msg);
    
    ~strdump("Sending message (send_raw_message)...");
    ;; Changed mode from 1 to 3 (1 + 2)
    ;; 1 - pay fees separately
    ;; 2 - ignore errors
    ;; 3 = 1 + 2 - pay fees separately and ignore errors
    send_raw_message(msg, 3);
    ~strdump("Message sent with mode = 3 (pay fees separately + ignore errors)");
    ~strdump("========== SEND_TRANSFER END ==========");
}

    () require_moderator(slice sender, slice moderator_address) impure inline {
        ~strdump(">> REQUIRE_MODERATOR CALL");
        ~dump(moderator_address);
        ~dump(sender);
        if (equal_slice_bits(sender, moderator_address) == 0) {
            ~strdump(">> ACCESS FORBIDDEN");
            ~dump(sender);
            throw(999);
        }
    }
    (int, cell, cell, cell, slice, int) load_data() impure {
        cell data = get_data();
        if (cell_null?(data)) {
            return (0, new_dict(), new_dict(), new_dict(), null(), 0);
        }
        slice ds = data.begin_parse();
        if (slice_empty?(ds)) {
            return (0, new_dict(), new_dict(), new_dict(), null(), 0);
        }
        int deals_counter = ds~load_uint(32);
        cell deals_dict = ds~load_dict();
        cell memo_map = ds~load_dict();
        cell unknown_funds = ds~load_dict();
        slice moderator_address = null();
        
        ;; Always try to load moderator address if we have data
        if (~ ds.slice_empty?()) {
            moderator_address = ds~load_msg_addr();
        }
        
        int commissions_pool = 0;
        if (~ ds.slice_empty?()) {
            commissions_pool = ds~load_uint(32);
        }
        
        return (deals_counter, deals_dict, memo_map, unknown_funds, moderator_address, commissions_pool);
    }

    () save_data(int dc, cell dd, cell mm, cell uf, slice ma, int cp) impure {
        ;; Explicitly create the cell with all data
        cell data_cell = begin_cell()
                .store_uint(dc, 32)  ;; Store deal counter
                .store_dict(dd)      ;; Store deals dictionary
                .store_dict(mm)      ;; Store memo map
                .store_dict(uf)      ;; Store unknown funds
                .store_slice(ma)     ;; Store moderator address
                .store_uint(cp, 32)  ;; Store commissions pool
            .end_cell();
        
        ;; Set the data cell as the persistent storage
        set_data(data_cell);
    }

    () recv_external(slice in_msg_cell) impure {
        accept_message(); ;; üîß –û–±—è–∑–∞—Ç–µ–ª—å–Ω–æ –¥–ª—è –∑–∞–ø–∏—Å–∏ —Å–æ—Å—Ç–æ—è–Ω–∏—è!
        ~strdump(">> EXTERNAL START");
        var (dc, dd, mm, uf, ma, cp) = load_data();
        slice cs = in_msg_cell;
        int op = cs~load_uint(32);
        slice sender = cs~load_msg_addr();
        require_moderator(sender, ma);
        ~strdump("in_msg_cell:");
        ~dump(in_msg_cell);
        
        ;;slice cs = in_msg_cell.begin_parse();
        
        if (op == op_create_deal) {
            slice s = cs~load_msg_addr();
            slice b = cs~load_msg_addr();
            int a = cs~load_coins();
            cell m = cs~load_ref();
            int mh = cell_hash(m);
            var (_, f) = mm.udict_get?(256, mh);
            throw_if(100, f);
            cell d = begin_cell()
                .store_slice(s)
                .store_slice(b)
                .store_coins(a)
                .store_uint(0, 1)
                .end_cell();
            int id = dc;
            dc = dc + 1;  ;; Changed from dc += 1 to dc = dc + 1
            dd~udict_set_ref(32, id, d);
            mm~udict_set(
                256,
                mh,
                begin_cell().store_uint(id, 32).end_cell().begin_parse()
            );
            
            ;; Save the updated data immediately
            save_data(dc, dd, mm, uf, ma, cp);
            
            ;; Return early to avoid saving data again at the end of the function
            return ();
        } elseif (op == op_resolve_deal) {
            ~strdump("resolve_deal: –ù–∞—á–∞–ª–æ –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è");
            
            cell m = cs~load_ref();
            ~strdump("resolve_deal: –ü–æ–ª—É—á–µ–Ω cell m:");
            ~dump(m);
            
            int x = cs~load_uint(1);
            ~strdump("resolve_deal: –§–ª–∞–≥ —É—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è (x):");
            ~dump(x);
            
            int mh = cell_hash(m);
            ~strdump("resolve_deal: –•—ç—à cell m (mh):");
            ~dump(mh);
            
            var (dslice, f) = mm.udict_get?(256, mh);
            throw_unless(110, f);
            ~strdump("resolve_deal: dslice –∏–∑ mm –¥–ª—è hash mh:");
            ~dump(dslice);
            
            int id = dslice~load_uint(32);
            ~strdump("resolve_deal: –ò–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä —Å–¥–µ–ª–∫–∏ (id):");
            ~dump(id);
            
            (cell c, int found) = dd.udict_get_ref?(32, id);
            throw_unless(140, found);
            ~strdump("resolve_deal: –ü–æ–ª—É—á–µ–Ω cell c (—Å–¥–µ–ª–∫–∞):");
            ~dump(c);
            
            slice d2 = c.begin_parse();
            slice s = d2~load_msg_addr();
            ~strdump("resolve_deal: –ê–¥—Ä–µ—Å –æ—Ç–ø—Ä–∞–≤–∏—Ç–µ–ª—è (s) —Å–¥–µ–ª–∫–∏:");
            ~dump(s);
            
            slice b = d2~load_msg_addr();
            ~strdump("resolve_deal: –ê–¥—Ä–µ—Å –ø–æ–ª—É—á–∞—Ç–µ–ª—è (b) —Å–¥–µ–ª–∫–∏:");
            ~dump(b);
            
            int amt = d2~load_coins();
            ~strdump("resolve_deal: –°—É–º–º–∞ —Å–¥–µ–ª–∫–∏ (amt):");
            ~dump(amt);
            
            int funded = d2~load_uint(1);
            ~strdump("resolve_deal: –§–ª–∞–≥ –æ–ø–ª–∞—Ç—ã —Å–¥–µ–ª–∫–∏ (funded):");
            ~dump(funded);
            
            throw_unless(111, funded);
            ~strdump("resolve_deal: –ó–Ω–∞—á–µ–Ω–∏–µ —Ñ–ª–∞–≥–∞ x –ø–æ—Å–ª–µ –∑–∞–≥—Ä—É–∑–∫–∏:");
            ~dump(x);
            
            if (x == 1) {
                ~strdump("resolve_deal: x == 1, –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å—Ä–µ–¥—Å—Ç–≤–∞ –ü–†–û–î–ê–í–¶–£");
                send_transfer(s, amt);
                ~strdump("–û—Ç–ø—Ä–∞–≤–∫–∞ S");
            } else {
                ~strdump("resolve_deal: x == 0, –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å—Ä–µ–¥—Å—Ç–≤–∞ –ü–û–ö–£–ü–ê–¢–ï–õ–Æ");
                send_transfer(b, amt);
                ~strdump("–û—Ç–ø—Ä–∞–≤–∫–∞ B");
            }
            dd~udict_delete?(32, id);
            mm~udict_delete?(256, mh);
            ~strdump("—É–¥–∞–ª–∏—Ç—å dd mm");
            ;; Save the updated data immediately
            save_data(dc, dd, mm, uf, ma, cp);
            ~strdump("save data");
            ;; Return early to avoid saving data again at the end of the function
            return ();
        } elseif (op == op_refund_unknown) {
            int k = cs~load_uint(32);
            (cell c, int f) = uf.udict_get_ref?(32, k);
            throw_unless(120, f);  ;; –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏—è –∑–∞–ø–∏—Å–∏
            
            slice ds2 = c.begin_parse();
            slice orig = ds2~load_msg_addr();
            int val = ds2~load_uint(128);
            
            ;; –°–Ω–∞—á–∞–ª–∞ —É–¥–∞–ª—è–µ–º –∑–∞–ø–∏—Å—å, –∑–∞—Ç–µ–º –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å—Ä–µ–¥—Å—Ç–≤–∞
            ;; –≠—Ç–æ –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ—Ç –ø–æ–≤—Ç–æ—Ä–Ω–æ–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ —Ç–æ–π –∂–µ –∑–∞–ø–∏—Å–∏
            uf~udict_delete?(32, k);
            
            ;; –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å—Ä–µ–¥—Å—Ç–≤–∞
            send_transfer(orig, val);
            
            ;; Save the updated data immediately
            save_data(dc, dd, mm, uf, ma, cp);
            
            ;; Return early to avoid saving data again at the end of the function
            return ();
        } elseif (op == op_withdraw_commissions) {
            ;;int amt = cs~load_coins();
            ;;–∂–∂throw_if(160, amt > cp);
            ;;cp -= amt;
            send_transfer(sender, cp);
            cp -= cp;
            ;; Save the updated data immediately
            save_data(dc, dd, mm, uf, ma, cp);
            
            ;; Return early to avoid saving data again at the end of the function
            return ();
        }
        save_data(dc, dd, mm, uf, ma, cp);
    }

() recv_internal(int msg_value, cell in_msg_full, slice in_msg_body) impure {
    accept_message();
    ~strdump(">> INTERNAL START");

    var (dc, dd, mm, uf, ma, cp) = load_data();
    slice msg_slice = in_msg_full.begin_parse();
    int flags = msg_slice~load_uint(4);
    slice sender = msg_slice~load_msg_addr();

    slice cs = in_msg_body;

    if (cs.slice_bits() >= 32) {
        int op = cs~load_uint(32);
        ~strdump("OP CODE:");
        ~dump(op);

        if (op == op_create_deal) {
            require_moderator(sender, ma);
            int query_id = cs~load_uint(64);
            slice s = cs~load_msg_addr();
            slice b = cs~load_msg_addr();

            ~strdump(">> CREATE_DEAL: –ê–¥—Ä–µ—Å –ø—Ä–æ–¥–∞–≤—Ü–∞ (s):");
            ~dump(s);
            ~strdump(">> CREATE_DEAL: –ê–¥—Ä–µ—Å –ø–æ–∫—É–ø–∞—Ç–µ–ª—è (b):");
            ~dump(b);

            int a = cs~load_coins();
            cell m = cs~load_ref();
            int mh = cell_hash(m);

            var (_, f) = mm.udict_get?(256, mh);
            throw_if(100, f);

            cell d = begin_cell()
                .store_slice(s)
                .store_slice(b)
                .store_coins(a)
                .store_uint(0, 1)
                .end_cell();

            int id = dc;
            dc = dc + 1;

            dd~udict_set_ref(32, id, d);
            mm~udict_set(
                256,
                mh,
                begin_cell().store_uint(id, 32).end_cell().begin_parse()
            );

            save_data(dc, dd, mm, uf, ma, cp);
            ~strdump("<<< CREATE COMPLETE");
            return ();
        } elseif (op == op_fund_deal) {
            ~strdump(">>> FUND_DEAL START");

            int query_id = cs~load_uint(64);
            cell m = cs~load_ref();
            int mh = cell_hash(m);

            var (dslice, f) = mm.udict_get?(256, mh);
            throw_unless(130, f);
            int id = dslice~load_uint(32);

            (cell c2, int found) = dd.udict_get_ref?(32, id);
            throw_unless(140, found);

            slice d2 = c2.begin_parse();
            slice s = d2~load_msg_addr();
            slice b = d2~load_msg_addr();
            int amt = d2~load_coins();
            int funded = d2~load_uint(1);

            throw_if(131, funded);
            throw_if(132, msg_value < amt);

            int comm = (amt * COMMISSION_WITH_MEMO) / 100;
            throw_if(132, msg_value < amt + comm);

            cp += comm;

            cell nd = begin_cell()
                .store_slice(s)
                .store_slice(b)
                .store_coins(amt)
                .store_uint(1, 1)
                .end_cell();

            dd~udict_set_ref(32, id, nd);

            save_data(dc, dd, mm, uf, ma, cp);
            ~strdump("<<< FUND_DEAL COMPLETE");
            return ();
        } elseif (op == op_refund_unknown) {
            require_moderator(sender, ma);
            int query_id = cs~load_uint(64);
            int k = cs~load_uint(32);

            (cell c, int f) = uf.udict_get_ref?(32, k);
            throw_unless(120, f);  ;; –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏—è –∑–∞–ø–∏—Å–∏

            slice us = c.begin_parse();
            slice orig = us~load_msg_addr();
            int val = us~load_uint(128);

            ;; –°–Ω–∞—á–∞–ª–∞ —É–¥–∞–ª—è–µ–º –∑–∞–ø–∏—Å—å, –∑–∞—Ç–µ–º –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å—Ä–µ–¥—Å—Ç–≤–∞
            uf~udict_delete?(32, k);
            
            ;; –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å—Ä–µ–¥—Å—Ç–≤–∞
            send_transfer(orig, val);

            save_data(dc, dd, mm, uf, ma, cp);
            return ();
        } else {
            ~strdump(">> stray payment msg_value =");
            ~dump(msg_value);
            ;; –ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π op-–∫–æ–¥ ‚Äî —Å—á–∏—Ç–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ ¬´–∑–∞–ª—ë—Ç–Ω—ã–º¬ª –ø–µ—Ä–µ–≤–æ–¥–æ–º
            
            ;; Check that the transfer amount is not less than the minimum
            throw_if(150, msg_value < 100000000); ;; Minimum 0.1 TON
            
            ;; Calculate commission (3%)
            int commission = (msg_value * COMMISSION_NO_MEMO) / 100;
            int net_value = msg_value - commission;
            cp += commission;

            int next_key = 0;
            var (_, exists) = uf.udict_get?(32, next_key);

            while (exists != 0) {       
                next_key += 1;
                var (_, exists) = uf.udict_get?(32, next_key);
            }

            ;; Log values for debugging
            ~strdump(">> Saving to unknown_funds:");
            ~strdump(">> Original amount:");
            ~dump(msg_value);
            ~strdump(">> Commission (3%):");
            ~dump(commission);
            ~strdump(">> Net amount:");
            ~dump(net_value);
            ~strdump(">> Key:");
            ~dump(next_key);

            cell rec = begin_cell()
                .store_slice(sender)
                .store_uint(net_value, 128)
                .end_cell();

            uf~udict_set_ref(32, next_key, rec);
            save_data(dc, dd, mm, uf, ma, cp);
            return ();
        }
    } else {
        ~strdump(">> stray payment (no op code) msg_value =");
        ~dump(msg_value);
        
        ;; Check that the transfer amount is not less than the minimum
        throw_if(150, msg_value < 100000000); ;; Minimum 0.1 TON
        
        ;; Calculate commission (3%)
        int commission = (msg_value * COMMISSION_NO_MEMO) / 100;
        int net_value = msg_value - commission;
        cp += commission;

        int next_key = 0;
        var (_, exists) = uf.udict_get?(32, next_key);

        while (exists != 0) {     
            next_key += 1;
            var (_, exists) = uf.udict_get?(32, next_key);
        }

        ;; Log values for debugging
        ~strdump(">> Saving to unknown_funds (no op code):");
        ~strdump(">> Original amount:");
        ~dump(msg_value);
        ~strdump(">> Commission (3%):");
        ~dump(commission);
        ~strdump(">> Net amount:");
        ~dump(net_value);
        ~strdump(">> Key:");
        ~dump(next_key);

        cell rec = begin_cell()
            .store_slice(sender)
            .store_uint(net_value, 128)  
            .end_cell();

        uf~udict_set_ref(32, next_key, rec);
        save_data(dc, dd, mm, uf, ma, cp);
        return ();
    }
   ;; save_data(dc, dd, mm, uf, ma, cp);
}


    (int, int) get_deal_info(int deal_id) method_id {
        var (dc, dd, mm, uf, ma, cp) = load_data();
        (cell c, int found) = dd.udict_get_ref?(32, deal_id);
        if (found == 0) {
            ~strdump("NOT FOUND");
            return (0, 0);
        }
        ~strdump("FOUND!");
        
        slice d2 = c.begin_parse();
        d2~load_msg_addr();  ;; Skip seller address
        d2~load_msg_addr();  ;; Skip buyer address
        int amt = d2~load_coins();  ;; Read amount
        int f = d2~load_uint(1);    ;; Read funded status
        
        return (amt, f);
    }

    int get_deal_counter() method_id {
        var (dc, dd, mm, uf, ma, cp) = load_data();
        return dc;
    }

    ;; Debug function to dump a deal
    (slice, slice, int, int) debug_get_deal(int deal_id) method_id {
        var (dc, dd, mm, uf, ma, cp) = load_data();
        (cell c, int found) = dd.udict_get_ref?(32, deal_id);
        if (found == 0) {
            return (null(), null(), 0, 0);
        }
        
        slice d2 = c.begin_parse();
        slice seller = d2~load_msg_addr();
        slice buyer = d2~load_msg_addr();
        int amt = d2~load_coins();
        int f = d2~load_uint(1);
        
        return (seller, buyer, amt, f);
    }

    ;; Debug function to get the moderator address
    slice get_moderator() method_id {
        var (dc, dd, mm, uf, ma, cp) = load_data();
        return ma;
    }

    ;; Debug function to dump all contract data
    (int, int, slice) debug_get_contract_data() method_id {
        var (dc, dd, mm, uf, ma, cp) = load_data();
        return (dc, cp, ma);
    }

    ;; Debug function to check if a deal exists
    int debug_deal_exists(int deal_id) method_id {
        var (dc, dd, mm, uf, ma, cp) = load_data();
        (_, int found) = dd.udict_get_ref?(32, deal_id);
        return found;
    }

    ;; Debug function to get the raw data cell
    cell debug_get_raw_data() method_id {
        return get_data();
    }
    ;; –≤–µ—Ä–Ω—É—Ç—å —Å—É–º–º—É (coins) –ø–æ –∫–ª—é—á—É unknown_funds, 0 –µ—Å–ª–∏ –∑–∞–ø–∏—Å–∏ –Ω–µ—Ç
    int get_unknown_fund(int key) method_id {
        var ( _ , _ , _ , uf , _ , _ ) = load_data();
        (cell c, int found) = uf.udict_get_ref?(32, key);
        if (found == 0) {          ;; —Ç–∞–∫–æ–π –∑–∞–ø–∏—Å–∏ –Ω–µ—Ç
            return 0;
        }
        slice s = c.begin_parse(); ;; (orig_addr, value)
        s~load_msg_addr();         ;; –ø—Ä–æ–ø—É—Å–∫–∞–µ–º –∞–¥—Ä–µ—Å
        int val = s~load_uint(128);
        return val;
    }
