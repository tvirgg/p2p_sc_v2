# Смарт-контракт P2P Escrow: Техническая документация

Этот документ представляет собой подробный технический обзор реализации смарт-контракта P2P Escrow. Он охватывает архитектуру контракта, структуры данных, функции и аспекты безопасности.

---

## Архитектура контракта

Смарт-контракт написан на языке **FunC** (язык смарт-контрактов TON) и использует шаблон с сохранением состояния. Он хранит данные в нескольких словарях для отслеживания сделок, меток и неопознанных средств.

### Переменные состояния

Состояние контракта включает:

```
(int deals_counter, cell deals_dict, cell memo_map, cell unknown_funds, slice moderator_address, int commissions_pool)
```

- `deals_counter`: 32-битный счётчик, увеличивается при создании каждой новой сделки  
- `deals_dict`: словарь, сопоставляющий ID сделки с её данными (ключ — 32-битный int)  
- `memo_map`: словарь, сопоставляющий хеши меток (256 бит) с ID сделок  
- `unknown_funds`: словарь с данными о средствах, отправленных без корректной идентификации  
- `moderator_address`: адрес модератора контракта  
- `commissions_pool`: накопленные комиссии (в nanoTONах)

---

## Структуры данных

### Данные сделки

Каждая сделка хранится в ячейке следующего вида:

```
begin_cell()
    .store_slice(seller)       // Адрес продавца
    .store_slice(buyer)        // Адрес покупателя
    .store_coins(amount)       // Сумма сделки в nanoTON
    .store_uint(is_funded, 1)  // Статус оплаты (0 — не оплачено, 1 — оплачено)
.end_cell()
```

### Хранение меток (Memo)

Хеш метки используется как ключ для поиска ID сделки:

```
memo_map~udict_set(
    256,
    memo_hash,
    begin_cell()
        .store_uint(deal_id, 32)
    .end_cell().begin_parse()
)
```

### Неопознанные средства

Если средства приходят без тела сообщения, они сохраняются в формате:

```
begin_cell()
    .store_slice(original_sender)  // Адрес отправителя
    .store_uint(value, 128)        // Сумма
.end_cell()
```

Ключ для хранения формируется так:

```
cell_hash(
    begin_cell()
        .store_slice(sender)
        .store_uint(value, 64)
    .end_cell()
)
```

---

## Обработчики сообщений

Контракт обрабатывает **внешние** и **внутренние** сообщения.

### Внешние сообщения (`recv_external`)

Используются для административных операций:

1. **Создание сделки** (`op_create_deal = 1`)  
2. **Разрешение сделки** (`op_resolve_deal = 2`)  
3. **Возврат неопознанных средств** (`op_refund_unknown = 3`)  
4. **Вывод комиссий** (`op_withdraw_commissions = 4`)  

> Все требуют авторизации модератора (пока отключена)

### Внутренние сообщения (`recv_internal`)

Используются для перевода средств и операций по сделке:

1. **Создание сделки** (`op_create_deal = 1`)  
2. **Оплата сделки** (`op_fund_deal = 5`)  
3. **Обработка неопознанных средств** — если сообщение без тела, считается неопознанным

---

## Методы `get`

Контракт предоставляет два метода для чтения состояния:

### `get_deal_info(deal_id)`

Возвращает:

```
(int amount, int is_funded)
```

### `get_deal_counter()`

Возвращает текущее значение счётчика сделок.

---

## Детали реализации

### Обработка сообщений

1. Загрузка текущего состояния  
2. Парсинг входящего сообщения  
3. Определение кода операции  
4. Выполнение операции  
5. Сохранение обновлённого состояния

### Операции со словарями

Используется реализация словарей (префиксное дерево) TON:

- `udict_get?` — получить значение  
- `udict_set` — установить значение  
- `udict_set_ref` — установить ячейку  
- `udict_delete?` — удалить значение по ключу  

### Перевод средств

Для отправки средств используется `send_raw_message` с режимом `1`:

```func
() send_transfer(slice dest, int grams) impure inline {
    var msg = begin_cell()
        .store_uint(0x10, 6)
        .store_slice(dest)
        .store_coins(grams)
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .end_cell();

    send_raw_message(msg, 1);
}
```

### Обработка ошибок

Используются `throw_if` и `throw_unless`:

- 100 — Дубликат метки  
- 110 — Метка не найдена  
- 111 — Сделка не оплачена  
- 120 — Неизвестный перевод не найден  
- 130 — Сделка по метке не найдена  
- 131 — Сделка уже оплачена  
- 132 — Недостаточно средств  
- 160 — Недостаточно комиссии для вывода  
- 999 — Нет прав (модераторская проверка)

---

## Безопасность

### Проверка модератора

Проверка прав отключена:

```func
;; require_moderator(sender, moderator_address); ;; временно отключено
```

При активации:

```func
() require_moderator(slice sender, slice moderator_address) impure inline {
    throw_unless(999, equal_slice_bits(sender, moderator_address));
}
```

### Комиссия

Фиксированная ставка:

```func
const int COMMISSION_WITH_MEMO = 3; // 3%
const int COMMISSION_NO_MEMO = 3;   // 3%
```

Расчёт:

```func
int commission = (amount * COMMISSION_WITH_MEMO) / 100;
```

### Уникальность меток

Использование хешей ячеек для идентификации сделок гарантирует уникальность.

### Инициализация состояния

Если состояние пусто — безопасно инициализируется:

```func
if (cell_null?(data)) {
    return (0, new_dict(), new_dict(), new_dict(), null(), 0);
}
```

---

## Оптимизация газа

### Inline-функции

Контракт активно использует `inline` для уменьшения потребления газа:

```func
() send_transfer(...)
int compute_unknown_id(...)
() require_moderator(...)
```

### Словари вместо ячеек

Использование словарей вместо хранения всех данных в одной ячейке позволяет масштабироваться.

---

## Обёртка на TypeScript (`P2P.ts`)

Облегчает взаимодействие с контрактом:

```ts
export class P2P implements Contract {
    static createFromAddress(address: Address)
    static createFromConfig(moderator: Address, code: Cell, workchain = 0)

    async sendDeploy(...)
    async sendCreateDeal(...)
    async sendFundDeal(...)
    async sendResolveDeal(...)
    async sendRefundUnknown(...)
    async sendWithdrawCommissions(...)

    async getDealInfo(...)
    async getDealCounter(...)
}
```

---

## Компиляция и развёртывание

Компиляция через TON Blueprint:

```ts
export const compile: CompilerConfig = {
    lang: 'func',
    targets: ['contracts/p2_p.fc'],
};
```

Развёртывание через `deployP2P.ts`:

```ts
await p2P.sendDeploy(provider.sender(), toNano('0.05'));
await provider.waitForDeploy(p2P.address);
```

---

## Будущие улучшения

### Возможные расширения

1. Истечение срока сделок  
2. Мультиподпись для дорогих сделок  
3. Улучшенная система споров  
4. Переменные комиссии  
5. Многоуровневый эскроу (например, поэтапная оплата)

### Ограничения

- Авторизация модератора отключена  
- Нет механизма тайм-аута  
- Нет поддержки частичной оплаты  
- Нельзя изменить модератора после деплоя  

---

## Заключение

Смарт-контракт P2P Escrow обеспечивает надёжную и гибкую инфраструктуру для сделок между покупателями и продавцами в экосистеме TON. Благодаря модульной архитектуре и продуманной логике он подходит для широкого спектра сценариев.
