import { Address, beginCell, toNano, Dictionary, Cell, Slice } from "ton-core";
import { compile } from "@ton-community/blueprint";
import { Blockchain, SandboxContract, TreasuryContract } from "@ton-community/sandbox";
import { P2P } from "../wrappers/P2P";
import '@ton-community/test-utils';
// Define constants from the contract
const COMMISSION_WITH_MEMO = 3; // 3% commission for deals with memo

describe("P2P Contract Sandbox", () => {
    let blockchain: Blockchain;
    let contract: SandboxContract<P2P>;
    let moderatorWallet: SandboxContract<TreasuryContract>;

    // –î–ª—è —Ç–µ—Å—Ç–æ–≤—ã—Ö —Ü–µ–ª–µ–π –∏—Å–ø–æ–ª—å–∑—É–µ–º —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–π hex –¥–ª—è –ø–æ–∫—É–ø–∞—Ç–µ–ª—è,
    // –∞ –¥–ª—è –ø—Ä–æ–¥–∞–≤—Ü–∞ –∏ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø–µ—Ä–µ–≤–æ–¥–∞ —Å—Ä–µ–¥—Å—Ç–≤ —Å–æ–∑–¥–∞—ë–º –∫–æ—à–µ–ª—å–∫–∏ —á–µ—Ä–µ–∑ sandbox.
    const BUYER_HEX  = "0:2222000022220000222200002222000022220000222200002222000022220000";

    beforeEach(async () => {
        // 1) –°–æ–∑–¥–∞—ë–º –ª–æ–∫–∞–ª—å–Ω—ã–π –±–ª–æ–∫—á–µ–π–Ω
        blockchain = await Blockchain.create();
        blockchain.verbosity = {
            blockchainLogs: true,
            vmLogs: "vm_logs",
            debugLogs: true,
            print: false,
        };

        // 2) –°–æ–∑–¥–∞—ë–º "–º–æ–¥–µ—Ä–∞—Ç–æ—Ä–∞" (–∫–æ—à–µ–ª—ë–∫)
        moderatorWallet = await blockchain.treasury("moderator");

        // 3) –ö–æ–º–ø–∏–ª–∏–º –∏—Å—Ö–æ–¥–Ω—ã–π –∫–æ–¥ –∫–æ–Ω—Ç—Ä–∞–∫—Ç–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä, P2P.fc)
        const code = await compile("P2P");

        // 4) –°–æ–∑–¥–∞—ë–º —ç–∫–∑–µ–º–ø–ª—è—Ä –∫–æ–Ω—Ç—Ä–∞–∫—Ç–∞ —á–µ—Ä–µ–∑ –æ–±—ë—Ä—Ç–∫—É
        const p2pConfig = P2P.createFromConfig(moderatorWallet.address, code, 0);

        // 5) "–û—Ç–∫—Ä—ã–≤–∞–µ–º" –∫–æ–Ω—Ç—Ä–∞–∫—Ç —á–µ—Ä–µ–∑ sandbox
        contract = blockchain.openContract(p2pConfig);

        // 6) –î–µ–ø–ª–æ–∏–º –∫–æ–Ω—Ç—Ä–∞–∫—Ç
        await contract.sendDeploy(
            moderatorWallet.getSender(),
            toNano("0.05")
        );
        
        process.stdout.write(`üöÄ –ö–æ–Ω—Ç—Ä–∞–∫—Ç –∑–∞–¥–µ–ø–ª–æ–µ–Ω –ø–æ –∞–¥—Ä–µ—Å—É: ${contract.address.toString()}\n`);
    });

    it("should create a deal", async () => {
        const SELLER = Address.parse("0:1111000011110000111100001111000011110000111100001111000011110000");
        const BUYER = Address.parse(BUYER_HEX);
        const dealAmount = toNano("2");
        const memoText = "1236";

        // –í—ã—á–∏—Å–ª—è–µ–º —Ö—ç—à memoCell (–¥–ª—è –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è)
        const memoCell = beginCell().storeStringTail(memoText).endCell();
        const memoHash = memoCell.hash().toString("hex");
        process.stdout.write(`üîñ Memo Hash: ${memoHash}\n`);

        process.stdout.write(`üèÅ –ö–æ–Ω—Ç—Ä–∞–∫—Ç –∞–¥—Ä–µ—Å: ${contract.address.toString()}\n`);
        process.stdout.write(`üèÅ –ú–æ–¥–µ—Ä–∞—Ç–æ—Ä –∞–¥—Ä–µ—Å: ${moderatorWallet.address.toString()}\n`);

        // –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∫–æ–Ω—Ç—Ä–∞–∫—Ç–∞ –¥–æ —Å–æ–∑–¥–∞–Ω–∏—è —Å–¥–µ–ª–∫–∏
        const contractDataBefore = await contract.getContractData();
        process.stdout.write(`üìä –î–∞–Ω–Ω—ã–µ –∫–æ–Ω—Ç—Ä–∞–∫—Ç–∞ –î–û: ${JSON.stringify(contractDataBefore)}\n`);
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∞–¥—Ä–µ—Å –º–æ–¥–µ—Ä–∞—Ç–æ—Ä–∞, –∑–∞–ø–∏—Å–∞–Ω–Ω—ã–π –≤ –∫–æ–Ω—Ç—Ä–∞–∫—Ç–µ
        const moderatorAddress = await contract.getModeratorAddress();
        process.stdout.write(`üëÆ –ú–æ–¥–µ—Ä–∞—Ç–æ—Ä –≤ –∫–æ–Ω—Ç—Ä–∞–∫—Ç–µ: ${moderatorAddress.toString()}\n`);
        expect(moderatorAddress.equals(moderatorWallet.address)).toBe(true);

        // –°–æ–∑–¥–∞—ë–º —Å–¥–µ–ª–∫—É
        const createResult = await contract.sendCreateDeal(
            moderatorWallet.getSender(),
            SELLER,
            BUYER,
            dealAmount,
            memoText
        );
        expect(createResult.transactions).toHaveTransaction({
            from: moderatorWallet.address,
            to: contract.address,
            success: true,
            op: 1,
        });
        process.stdout.write(`‚úÖ –°–¥–µ–ª–∫–∞ —Å–æ–∑–¥–∞–Ω–∞\n`);

        // –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∫–æ–Ω—Ç—Ä–∞–∫—Ç–∞ –ø–æ—Å–ª–µ —Å–æ–∑–¥–∞–Ω–∏—è —Å–¥–µ–ª–∫–∏
        const contractDataAfter = await contract.getContractData();
        process.stdout.write(`üìä –î–∞–Ω–Ω—ã–µ –∫–æ–Ω—Ç—Ä–∞–∫—Ç–∞ –ü–û–°–õ–ï: ${JSON.stringify(contractDataAfter)}\n`);

        // –ü–æ–ª—É—á–∞–µ–º —Å—á—ë—Ç—á–∏–∫ —Å–¥–µ–ª–æ–∫
        const dealCounter = await contract.getDealCounter();
        process.stdout.write(`üìä dealCounter = ${dealCounter}\n`);
        expect(dealCounter).toBe(1);

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º getDealInfo(0)
        const infoBefore = await contract.getDealInfo(0);
        process.stdout.write(`üßÆ Deal Info (index=0) = ${JSON.stringify({
            ...infoBefore,
            amount: infoBefore.amount
        }, (key, value) => typeof value === 'bigint' ? value.toString() : value)}\n`);
        expect(infoBefore.amount.toString()).toBe(dealAmount.toString());
        expect(infoBefore.funded).toBe(0);

        // –ü–æ–ª—É—á–∞–µ–º –ø–æ–ª–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Å–¥–µ–ª–∫–µ (–¥–ª—è –æ—Ç–ª–∞–¥–∫–∏)
        try {
            const fullDealInfo = await contract.getFullDealInfo(0);
            process.stdout.write(`üìã –ü–æ–ª–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —Å–¥–µ–ª–∫–µ: ${JSON.stringify(fullDealInfo)}\n`);
        } catch (error) {
            process.stdout.write(`‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –ø–æ–ª–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ —Å–¥–µ–ª–∫–µ: ${error}\n`);
        }
    });

    it("should create and fund a deal", async () => {
        const SELLER = Address.parse("0:1111000011110000111100001111000011110000111100001111000011110000");
        const BUYER = Address.parse(BUYER_HEX);
        const dealAmount = toNano("2");
        const memoText = "DEAL:1";

        // –°–æ–∑–¥–∞—ë–º –∫–æ—à–µ–ª—ë–∫ –ø–æ–∫—É–ø–∞—Ç–µ–ª—è –¥–ª—è —Ñ–∏–Ω–∞–Ω—Å–∏—Ä–æ–≤–∞–Ω–∏—è —Å–¥–µ–ª–∫–∏
        const buyerWallet = await blockchain.treasury("buyer");

        // –ü–æ–ª—É—á–∞–µ–º –±–∞–ª–∞–Ω—Å –ø–æ–∫—É–ø–∞—Ç–µ–ª—è –î–û —Ñ–∏–Ω–∞–Ω—Å–∏—Ä–æ–≤–∞–Ω–∏—è
        const buyerBalanceBefore = await buyerWallet.getBalance();
        process.stdout.write(`üí≥ –ë–∞–ª–∞–Ω—Å –ø–æ–∫—É–ø–∞—Ç–µ–ª—è –î–û —Ñ–∏–Ω–∞–Ω—Å–∏—Ä–æ–≤–∞–Ω–∏—è: ${buyerBalanceBefore.toString()}\n`);

        // –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∫–æ–Ω—Ç—Ä–∞–∫—Ç–∞ –¥–æ —Å–æ–∑–¥–∞–Ω–∏—è —Å–¥–µ–ª–∫–∏
        const contractDataBefore = await contract.getContractData();
        process.stdout.write(`üìä –î–∞–Ω–Ω—ã–µ –∫–æ–Ω—Ç—Ä–∞–∫—Ç–∞ –î–û: ${JSON.stringify(contractDataBefore)}\n`);
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –º–æ–¥–µ—Ä–∞—Ç–æ—Ä –∑–∞–ø–∏—Å–∞–Ω –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ
        const moderatorAddress = await contract.getModeratorAddress();
        process.stdout.write(`üëÆ –ú–æ–¥–µ—Ä–∞—Ç–æ—Ä –≤ –∫–æ–Ω—Ç—Ä–∞–∫—Ç–µ: ${moderatorAddress.toString()}\n`);
        expect(moderatorAddress.equals(moderatorWallet.address)).toBe(true);

        // –®–∞–≥ 1: —Å–æ–∑–¥–∞—ë–º —Å–¥–µ–ª–∫—É
        const createResult = await contract.sendCreateDeal(
            moderatorWallet.getSender(),
            SELLER,
            BUYER,
            dealAmount,
            memoText
        );
        process.stdout.write(`‚úÖ –°–¥–µ–ª–∫–∞ —Å–æ–∑–¥–∞–Ω–∞\n`);
        
        // –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è —Ä–µ–∫—É—Ä—Å–∏–≤–Ω–æ–≥–æ –≤—ã–≤–æ–¥–∞ debug logs –∏–∑ –≤—Å–µ—Ö —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π
        function printAllDebugLogs(transaction: any): void {
            if (!transaction) return;
            
            // –í—ã–≤–æ–¥ debug logs –∏–∑ —Ç–µ–∫—É—â–µ–π —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
            if (transaction.debugLogs) {
                process.stdout.write(`üìã DEBUG LOGS (${transaction.address || 'unknown'}):\n`);
                transaction.debugLogs.split('\n').forEach((line: string) => {
                    if (line.trim()) {
                        process.stdout.write(`    ${line}\n`);
                    }
                });
            }
            
            // –†–µ–∫—É—Ä—Å–∏–≤–Ω–æ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –¥–æ—á–µ—Ä–Ω–∏–µ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
            if (transaction.children && Array.isArray(transaction.children)) {
                transaction.children.forEach((child: any) => printAllDebugLogs(child));
            }
        }
        
        // –í—ã–≤–æ–¥–∏–º –≤—Å–µ debug logs –∏–∑ –∏–µ—Ä–∞—Ä—Ö–∏–∏ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π
        process.stdout.write(`üîç –í–°–ï DEBUG LOGS –î–õ–Ø createResult:\n`);
        printAllDebugLogs(createResult);
        // –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∫–æ–Ω—Ç—Ä–∞–∫—Ç–∞ –ø–æ—Å–ª–µ —Å–æ–∑–¥–∞–Ω–∏—è —Å–¥–µ–ª–∫–∏
        const contractDataAfterCreate = await contract.getContractData();
        process.stdout.write(`üìä –î–∞–Ω–Ω—ã–µ –∫–æ–Ω—Ç—Ä–∞–∫—Ç–∞ –ü–û–°–õ–ï —Å–æ–∑–¥–∞–Ω–∏—è: ${JSON.stringify(contractDataAfterCreate)}\n`);

        const dealCounterAfterCreate = await contract.getDealCounter();
        process.stdout.write(`üìà Deal counter –ø–æ—Å–ª–µ —Å–æ–∑–¥–∞–Ω–∏—è: ${dealCounterAfterCreate}\n`);

        // –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Å–¥–µ–ª–∫–µ –î–û —Ñ–∏–Ω–∞–Ω—Å–∏—Ä–æ–≤–∞–Ω–∏—è
        const dealInfoBeforeFunding = await contract.getDealInfo(0);
        process.stdout.write(`üì¶ –î–∞–Ω–Ω—ã–µ —Å–¥–µ–ª–∫–∏ –î–û —Ñ–∏–Ω–∞–Ω—Å–∏—Ä–æ–≤–∞–Ω–∏—è: ${JSON.stringify({
            amount: dealInfoBeforeFunding.amount,
            funded: dealInfoBeforeFunding.funded
        }, (key, value) => typeof value === 'bigint' ? value.toString() : value)}\n`);

        // –ü–æ–ª—É—á–∞–µ–º –ø–æ–ª–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Å–¥–µ–ª–∫–µ –î–û —Ñ–∏–Ω–∞–Ω—Å–∏—Ä–æ–≤–∞–Ω–∏—è
        const fullDealInfoBeforeFunding = await contract.getFullDealInfo(0);
        process.stdout.write(`üìã –ü–æ–ª–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —Å–¥–µ–ª–∫–µ –î–û —Ñ–∏–Ω–∞–Ω—Å–∏—Ä–æ–≤–∞–Ω–∏—è: ${JSON.stringify(fullDealInfoBeforeFunding, (key, value) => typeof value === 'bigint' ? value.toString() : value)}\n`);

        // –®–∞–≥ 2: —Ñ–∏–Ω–∞–Ω—Å–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–¥–µ–ª–∫–∏
        await contract.sendFundDeal(
            buyerWallet.getSender(),
            memoText,
            toNano("2.1") // —á—É—Ç—å –±–æ–ª—å—à–µ –¥–ª—è —É—á—ë—Ç–∞ –∫–æ–º–∏—Å—Å–∏–∏
        );
        process.stdout.write(`üí∞ –°–¥–µ–ª–∫–∞ –ø—Ä–æ—Ñ–∏–Ω–∞–Ω—Å–∏—Ä–æ–≤–∞–Ω–∞\n`);

        // –ü–æ–ª—É—á–∞–µ–º –±–∞–ª–∞–Ω—Å –ø–æ–∫—É–ø–∞—Ç–µ–ª—è –ü–û–°–õ–ï —Ñ–∏–Ω–∞–Ω—Å–∏—Ä–æ–≤–∞–Ω–∏—è
        const buyerBalanceAfter = await buyerWallet.getBalance();
        process.stdout.write(`üí≥ –ë–∞–ª–∞–Ω—Å –ø–æ–∫—É–ø–∞—Ç–µ–ª—è –ü–û–°–õ–ï —Ñ–∏–Ω–∞–Ω—Å–∏—Ä–æ–≤–∞–Ω–∏—è: ${buyerBalanceAfter.toString()}\n`);

        // –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∫–æ–Ω—Ç—Ä–∞–∫—Ç–∞ –ü–û–°–õ–ï —Ñ–∏–Ω–∞–Ω—Å–∏—Ä–æ–≤–∞–Ω–∏—è
        const contractDataAfterFunding = await contract.getContractData();
        process.stdout.write(`üìä –î–∞–Ω–Ω—ã–µ –∫–æ–Ω—Ç—Ä–∞–∫—Ç–∞ –ü–û–°–õ–ï —Ñ–∏–Ω–∞–Ω—Å–∏—Ä–æ–≤–∞–Ω–∏—è: ${JSON.stringify(contractDataAfterFunding)}\n`);

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ —Å–¥–µ–ª–∫–∏ –ø–æ—Å–ª–µ —Ñ–∏–Ω–∞–Ω—Å–∏—Ä–æ–≤–∞–Ω–∏—è
        const dealInfoAfterFunding = await contract.getDealInfo(0);
        process.stdout.write(`üì¶ –î–∞–Ω–Ω—ã–µ —Å–¥–µ–ª–∫–∏ –ü–û–°–õ–ï —Ñ–∏–Ω–∞–Ω—Å–∏—Ä–æ–≤–∞–Ω–∏—è: ${JSON.stringify({
            amount: dealInfoAfterFunding.amount.toString(),
            funded: dealInfoAfterFunding.funded
        })}\n`);
        expect(dealInfoAfterFunding.amount.toString()).toBe(dealAmount.toString());
        expect(dealInfoAfterFunding.funded).toBe(1);

        // –ü–æ–ª—É—á–∞–µ–º –ø–æ–ª–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Å–¥–µ–ª–∫–µ –ü–û–°–õ–ï —Ñ–∏–Ω–∞–Ω—Å–∏—Ä–æ–≤–∞–Ω–∏—è (–¥–ª—è –æ—Ç–ª–∞–¥–∫–∏)
        const fullDealInfoAfterFunding = await contract.getFullDealInfo(0);
        process.stdout.write(`üìã –ü–æ–ª–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —Å–¥–µ–ª–∫–µ –ü–û–°–õ–ï —Ñ–∏–Ω–∞–Ω—Å–∏—Ä–æ–≤–∞–Ω–∏—è: ${JSON.stringify(fullDealInfoAfterFunding, (key, value) => typeof value === 'bigint' ? value.toString() : value)}\n`);
    });

    // Commented out due to failing test
    it("should resolve deal in favor of seller", async () => {
        // –î–ª—è –¥–∞–Ω–Ω–æ–≥–æ —Ç–µ—Å—Ç–∞ —Å–æ–∑–¥–∞—ë–º –∫–æ—à–µ–ª—å–∫–∏ –¥–ª—è –ø—Ä–æ–¥–∞–≤—Ü–∞ –∏ –ø–æ–∫—É–ø–∞—Ç–µ–ª—è,
        // —á—Ç–æ–±—ã –º–æ–∂–Ω–æ –±—ã–ª–æ –ø—Ä–æ–≤–µ—Ä–∏—Ç—å –ø–µ—Ä–µ–≤–æ–¥ —Å—Ä–µ–¥—Å—Ç–≤ –ø—Ä–æ–¥–∞–≤—Ü—É.
        const sellerWallet = await blockchain.treasury("seller");
        const buyerWallet = await blockchain.treasury("buyer");

        process.stdout.write(`üèÅ –ü—Ä–æ–¥–∞–≤–µ—Ü –∞–¥—Ä–µ—Å: ${sellerWallet.address.toString()}\n`);
        process.stdout.write(`üèÅ –ü–æ–∫—É–ø–∞—Ç–µ–ª—å –∞–¥—Ä–µ—Å: ${buyerWallet.address.toString()}\n`);
        const dealAmount = toNano("2");
        const memoText = "deal-to-seller";
        const buyerBalanceStart = await buyerWallet.getBalance();
        process.stdout.write(`Buyer balance START resolution: ${buyerBalanceStart.toString()}\n`);
        // –®–∞–≥ 1: —Å–æ–∑–¥–∞—ë–º —Å–¥–µ–ª–∫—É (–≤ –¥–∞–Ω–Ω–æ–º —Å–ª—É—á–∞–µ –∞–¥—Ä–µ—Å –ø—Ä–æ–¥–∞–≤—Ü–∞ –±–µ—Ä—ë–º –∏–∑ –∫–æ—à–µ–ª—å–∫–∞)
        const createResult = await contract.sendCreateDeal(
            moderatorWallet.getSender(),
            sellerWallet.address,
            buyerWallet.address,
            dealAmount,
            memoText
        );
        // –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è —Ä–µ–∫—É—Ä—Å–∏–≤–Ω–æ–≥–æ –≤—ã–≤–æ–¥–∞ debug logs –∏–∑ –≤—Å–µ—Ö —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π
        function extractAndPrintAllDebugLogs(obj: any, visited = new Set()): void {
            if (!obj || typeof obj !== 'object' || visited.has(obj)) return;
            visited.add(obj);
        
            if (typeof obj.debugLogs === 'string') {
                process.stdout.write(`üìã DEBUG LOGS:\n`);
                obj.debugLogs.split('\n').forEach((line: string) => {
                    if (line.trim()) {
                        process.stdout.write(`    ${line}\n`);
                    }
                });
            }
        
            for (const key in obj) {
                if (obj.hasOwnProperty(key)) {
                    const val = obj[key];
        
                    if (Array.isArray(val)) {
                        val.forEach((child) => extractAndPrintAllDebugLogs(child, visited));
                    } else if (typeof val === 'object' && val !== null) {
                        extractAndPrintAllDebugLogs(val, visited);
                    }
                }
            }
        }
        
        // –í—ã–≤–æ–¥–∏–º –≤—Å–µ debug logs –∏–∑ –∏–µ—Ä–∞—Ä—Ö–∏–∏ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π
        process.stdout.write(`üîç –í–°–ï DEBUG LOGS –î–õ–Ø createResult:\n`);
        extractAndPrintAllDebugLogs(createResult);
        
        process.stdout.write(`‚úÖ –°–¥–µ–ª–∫–∞ —Å–æ–∑–¥–∞–Ω–∞ –¥–ª—è —Ç–µ—Å—Ç–∞ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏—è\n`);

        // –®–∞–≥ 2: —Ñ–∏–Ω–∞–Ω—Å–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–¥–µ–ª–∫–∏
        await contract.sendFundDeal(
            buyerWallet.getSender(),
            memoText,
            toNano("2.1")
        );
        process.stdout.write(`üí∞ –°–¥–µ–ª–∫–∞ –ø—Ä–æ—Ñ–∏–Ω–∞–Ω—Å–∏—Ä–æ–≤–∞–Ω–∞ –¥–ª—è —Ç–µ—Å—Ç–∞ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏—è\n`);
        const buyerBalanceSend = await buyerWallet.getBalance();
        process.stdout.write(`Buyer balance AFTER SEND: ${buyerBalanceSend.toString()}\n`);
        // –ü–æ–ª—É—á–∞–µ–º –±–∞–ª–∞–Ω—Å –ø—Ä–æ–¥–∞–≤—Ü–∞ –¥–æ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏—è —Å–¥–µ–ª–∫–∏
        const sellerBalanceBefore = await sellerWallet.getBalance();
        process.stdout.write(`Seller balance BEFORE resolution: ${sellerBalanceBefore.toString()}\n`);

        // –®–∞–≥ 3: —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–µ —Å–¥–µ–ª–∫–∏ –≤ –ø–æ–ª—å–∑—É –ø—Ä–æ–¥–∞–≤—Ü–∞ (approvePayment = true)
        const resolveResult = await contract.sendResolveDealExternal( // Call the corrected function
            moderatorWallet.getSender(),  // Use getSender() to get a Sender object
            memoText,                 // The crucial memo
            true                     
        );

        // Log the full resolveResult object for debugging
        if (resolveResult && Array.isArray(resolveResult.transactions) && resolveResult.transactions.length > 0) {
            // 2. –ë–µ—Ä–µ–º –ø–µ—Ä–≤—É—é —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é
            const firstTransaction = resolveResult.transactions[0];
        
            // 3. –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ debugLogs –≤–Ω—É—Ç—Ä–∏ —ç—Ç–æ–π —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ –∏ —á—Ç–æ –∑–Ω–∞—á–µ–Ω–∏–µ –Ω–µ –ø—É—Å—Ç–æ–µ/null/undefined
            if ('debugLogs' in firstTransaction && firstTransaction.debugLogs) {
            // 4. –í—ã–≤–æ–¥–∏–º debugLogs –∏–∑ –ø–µ—Ä–≤–æ–π —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏, –∫–∞–∂–¥—É—é —Å—Ç—Ä–æ–∫—É –Ω–∞ –æ—Ç–¥–µ–ª—å–Ω–æ–π —Å—Ç—Ä–æ–∫–µ
            const debugLogs = firstTransaction.debugLogs.split('\n');
            debugLogs.forEach((logLine) => {
                process.stdout.write(`üìã Debug Log Line: ${logLine}\n`);
            });
            } else {
            // –°–æ–æ–±—â–µ–Ω–∏–µ, –µ—Å–ª–∏ debugLogs –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –∏–ª–∏ –ø—É—Å—Ç –≤ –ø–µ—Ä–≤–æ–π —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
            process.stdout.write(`üìã Debug Logs: null or empty in the first transaction\n`);
            }
        } else {
            // –°–æ–æ–±—â–µ–Ω–∏–µ, –µ—Å–ª–∏ –º–∞—Å—Å–∏–≤ transactions –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –∏–ª–∏ –ø—É—Å—Ç
            process.stdout.write(`üìã Debug Logs: No transactions found or transactions array is empty\n`);
        }
        expect(resolveResult.transactions).toHaveTransaction({
            to: contract.address,
            on: contract.address,
            success: true,
            op: 2,
        });
        process.stdout.write(`‚úÖ –°–¥–µ–ª–∫–∞ —Ä–∞–∑—Ä–µ—à–µ–Ω–∞ –≤ –ø–æ–ª—å–∑—É –ø—Ä–æ–¥–∞–≤—Ü–∞\n`);

        // –ü–æ–ª—É—á–∞–µ–º –±–∞–ª–∞–Ω—Å –ø—Ä–æ–¥–∞–≤—Ü–∞ –ø–æ—Å–ª–µ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏—è —Å–¥–µ–ª–∫–∏
        const sellerBalanceAfter = await sellerWallet.getBalance();
        process.stdout.write(`Seller balance AFTER resolution: ${sellerBalanceAfter.toString()}\n`);
        const buyerBalanceAfter = await buyerWallet.getBalance();
        process.stdout.write(`Buyer balance AFTER resolution: ${buyerBalanceAfter.toString()}\n`);

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –ø—Ä–æ–¥–∞–≤–µ—Ü –ø–æ–ª—É—á–∏–ª –∫–∞–∫ –º–∏–Ω–∏–º—É–º —Å—É–º–º—É —Å–¥–µ–ª–∫–∏ –º–∏–Ω—É—Å –∫–æ–º–∏—Å—Å–∏—é
        const fee = (dealAmount * BigInt(COMMISSION_WITH_MEMO)) / 100n; // 3% commission
        const margin = toNano("0.03"); // Allowable margin for transaction fees
        // Convert all values to BigInt to ensure type compatibility
        expect(BigInt(sellerBalanceAfter) - BigInt(sellerBalanceBefore) + BigInt(margin)).toBeGreaterThanOrEqual(BigInt(dealAmount) - fee);
    });


    it("should resolve deal in favor of buyer", async () => {
        // –î–ª—è –¥–∞–Ω–Ω–æ–≥–æ —Ç–µ—Å—Ç–∞ —Å–æ–∑–¥–∞—ë–º –∫–æ—à–µ–ª—å–∫–∏ –¥–ª—è –ø—Ä–æ–¥–∞–≤—Ü–∞ –∏ –ø–æ–∫—É–ø–∞—Ç–µ–ª—è,
        // —á—Ç–æ–±—ã –º–æ–∂–Ω–æ –±—ã–ª–æ –ø—Ä–æ–≤–µ—Ä–∏—Ç—å –ø–µ—Ä–µ–≤–æ–¥ —Å—Ä–µ–¥—Å—Ç–≤ –ø—Ä–æ–¥–∞–≤—Ü—É.
        const sellerWallet = await blockchain.treasury("seller");
        const buyerWallet = await blockchain.treasury("buyer");

        process.stdout.write(`üèÅ –ü—Ä–æ–¥–∞–≤–µ—Ü –∞–¥—Ä–µ—Å: ${sellerWallet.address.toString()}\n`);
        process.stdout.write(`üèÅ –ü–æ–∫—É–ø–∞—Ç–µ–ª—å –∞–¥—Ä–µ—Å: ${buyerWallet.address.toString()}\n`);
        const dealAmount = toNano("2");
        const memoText = "deal-to-seller";
        const buyerBalanceStart = await buyerWallet.getBalance();
        process.stdout.write(`Buyer balance START resolution: ${buyerBalanceStart.toString()}\n`);
        // –®–∞–≥ 1: —Å–æ–∑–¥–∞—ë–º —Å–¥–µ–ª–∫—É (–≤ –¥–∞–Ω–Ω–æ–º —Å–ª—É—á–∞–µ –∞–¥—Ä–µ—Å –ø—Ä–æ–¥–∞–≤—Ü–∞ –±–µ—Ä—ë–º –∏–∑ –∫–æ—à–µ–ª—å–∫–∞)
        const createResult = await contract.sendCreateDeal(
            moderatorWallet.getSender(),
            sellerWallet.address,
            buyerWallet.address,
            dealAmount,
            memoText
        );
        // –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è —Ä–µ–∫—É—Ä—Å–∏–≤–Ω–æ–≥–æ –≤—ã–≤–æ–¥–∞ debug logs –∏–∑ –≤—Å–µ—Ö —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π
        function extractAndPrintAllDebugLogs(obj: any, visited = new Set()): void {
            if (!obj || typeof obj !== 'object' || visited.has(obj)) return;
            visited.add(obj);
        
            if (typeof obj.debugLogs === 'string') {
                process.stdout.write(`üìã DEBUG LOGS:\n`);
                obj.debugLogs.split('\n').forEach((line: string) => {
                    if (line.trim()) {
                        process.stdout.write(`    ${line}\n`);
                    }
                });
            }
        
            for (const key in obj) {
                if (obj.hasOwnProperty(key)) {
                    const val = obj[key];
        
                    if (Array.isArray(val)) {
                        val.forEach((child) => extractAndPrintAllDebugLogs(child, visited));
                    } else if (typeof val === 'object' && val !== null) {
                        extractAndPrintAllDebugLogs(val, visited);
                    }
                }
            }
        }
        
        // –í—ã–≤–æ–¥–∏–º –≤—Å–µ debug logs –∏–∑ –∏–µ—Ä–∞—Ä—Ö–∏–∏ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π
        process.stdout.write(`üîç –í–°–ï DEBUG LOGS –î–õ–Ø createResult:\n`);
        extractAndPrintAllDebugLogs(createResult);
        
        process.stdout.write(`‚úÖ –°–¥–µ–ª–∫–∞ —Å–æ–∑–¥–∞–Ω–∞ –¥–ª—è —Ç–µ—Å—Ç–∞ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏—è\n`);

        // –®–∞–≥ 2: —Ñ–∏–Ω–∞–Ω—Å–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–¥–µ–ª–∫–∏
        await contract.sendFundDeal(
            buyerWallet.getSender(),
            memoText,
            toNano("2.1")
        );
        process.stdout.write(`üí∞ –°–¥–µ–ª–∫–∞ –ø—Ä–æ—Ñ–∏–Ω–∞–Ω—Å–∏—Ä–æ–≤–∞–Ω–∞ –¥–ª—è —Ç–µ—Å—Ç–∞ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏—è\n`);
        const buyerBalanceSend = await buyerWallet.getBalance();
        process.stdout.write(`Buyer balance AFTER SEND: ${buyerBalanceSend.toString()}\n`);
        // –ü–æ–ª—É—á–∞–µ–º –±–∞–ª–∞–Ω—Å –ø—Ä–æ–¥–∞–≤—Ü–∞ –¥–æ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏—è —Å–¥–µ–ª–∫–∏
        const sellerBalanceBefore = await sellerWallet.getBalance();
        process.stdout.write(`Seller balance BEFORE resolution: ${sellerBalanceBefore.toString()}\n`);

        // –®–∞–≥ 3: —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–µ —Å–¥–µ–ª–∫–∏ –≤ –ø–æ–ª—å–∑—É –ø—Ä–æ–¥–∞–≤—Ü–∞ (approvePayment = true)
        const resolveResult = await contract.sendResolveDealExternal( // Call the corrected function
            moderatorWallet.getSender(),  // Use getSender() to get a Sender object
            memoText,                 // The crucial memo
            false                     
        );

        // Log the full resolveResult object for debugging
        if (resolveResult && Array.isArray(resolveResult.transactions) && resolveResult.transactions.length > 0) {
            // 2. –ë–µ—Ä–µ–º –ø–µ—Ä–≤—É—é —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é
            const firstTransaction = resolveResult.transactions[0];
        
            // 3. –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ debugLogs –≤–Ω—É—Ç—Ä–∏ —ç—Ç–æ–π —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ –∏ —á—Ç–æ –∑–Ω–∞—á–µ–Ω–∏–µ –Ω–µ –ø—É—Å—Ç–æ–µ/null/undefined
            if ('debugLogs' in firstTransaction && firstTransaction.debugLogs) {
            // 4. –í—ã–≤–æ–¥–∏–º debugLogs –∏–∑ –ø–µ—Ä–≤–æ–π —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏, –∫–∞–∂–¥—É—é —Å—Ç—Ä–æ–∫—É –Ω–∞ –æ—Ç–¥–µ–ª—å–Ω–æ–π —Å—Ç—Ä–æ–∫–µ
            const debugLogs = firstTransaction.debugLogs.split('\n');
            debugLogs.forEach((logLine) => {
                process.stdout.write(`üìã Debug Log Line: ${logLine}\n`);
            });
            } else {
            // –°–æ–æ–±—â–µ–Ω–∏–µ, –µ—Å–ª–∏ debugLogs –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –∏–ª–∏ –ø—É—Å—Ç –≤ –ø–µ—Ä–≤–æ–π —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
            process.stdout.write(`üìã Debug Logs: null or empty in the first transaction\n`);
            }
        } else {
            // –°–æ–æ–±—â–µ–Ω–∏–µ, –µ—Å–ª–∏ –º–∞—Å—Å–∏–≤ transactions –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –∏–ª–∏ –ø—É—Å—Ç
            process.stdout.write(`üìã Debug Logs: No transactions found or transactions array is empty\n`);
        }
        expect(resolveResult.transactions).toHaveTransaction({
            to: contract.address,
            on: contract.address,
            success: true,
            op: 2,
        });
        process.stdout.write(`‚úÖ –°–¥–µ–ª–∫–∞ —Ä–∞–∑—Ä–µ—à–µ–Ω–∞ –≤ –ø–æ–ª—å–∑—É –ø–æ–∫—É–ø–∞—Ç–µ–ª—è\n`);

        // –ü–æ–ª—É—á–∞–µ–º –±–∞–ª–∞–Ω—Å –ø—Ä–æ–¥–∞–≤—Ü–∞ –ø–æ—Å–ª–µ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏—è —Å–¥–µ–ª–∫–∏
        const sellerBalanceAfter = await sellerWallet.getBalance();
        process.stdout.write(`Seller balance AFTER resolution: ${sellerBalanceAfter.toString()}\n`);
        const buyerBalanceAfter = await buyerWallet.getBalance();
        process.stdout.write(`Buyer balance AFTER resolution: ${buyerBalanceAfter.toString()}\n`);

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –ø–æ–∫—É–ø–∞—Ç–µ–ª—å –Ω–µ –ø–æ—Ç–µ—Ä—è–ª –±–æ–ª—å—à–µ, —á–µ–º –∫–æ–º–∏—Å—Å–∏—é + —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–æ–Ω–Ω—ã–µ –∏–∑–¥–µ—Ä–∂–∫–∏
        const commission = (dealAmount * BigInt(COMMISSION_WITH_MEMO)) / 100n; // 3% commission
        const margin = toNano("0.05"); // Allowable margin for transaction fees
        // Convert to BigInt to ensure type compatibility
        expect(BigInt(buyerBalanceStart) - BigInt(buyerBalanceAfter)).toBeLessThanOrEqual(commission + BigInt(margin));
    });

    // Commented out due to failing test
// -------------------- tests/P2P.test.ts --------------------
it("should allow moderator to withdraw commissions", async () => {
    /* 1. –ì–æ—Ç–æ–≤–∏–º —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤ */
    const sellerWallet = await blockchain.treasury("seller");
    const buyerWallet = await blockchain.treasury(
        "buyer",
        { balance: toNano("1000000") }
    )
    
    const dealAmount   = toNano("2000");
    const iterations   = 10;                 // ‚â• 9 ‚Üí cp > 0.5 TON

    /* 2. –ù–∞–∫—Ä—É—á–∏–≤–∞–µ–º –ø—É–ª –∫–æ–º–∏—Å—Å–∏–π */
    for (let i = 0; i < iterations; i++) {
        const memo = `bulk-${i}`;
        await contract.sendCreateDeal(
            moderatorWallet.getSender(),
            sellerWallet.address,
            buyerWallet.address,
            dealAmount,
            memo
        );
        await contract.sendFundDeal(
            buyerWallet.getSender(),
            memo,
            toNano("2000.1")
        );
        await contract.sendResolveDealExternal(
            moderatorWallet.getSender(),
            memo,
            true                         // –∫ –ø—Ä–æ–¥–∞–≤—Ü—É ‚áí –∫–æ–º–∏—Å—Å–∏—è –≤ –ø—É–ª
        );
    }

    /* 3. –°–∫–æ–ª—å–∫–æ –Ω–∞–∫–æ–ø–∏–ª–∏ –ø–µ—Ä–µ–¥ –≤—ã–≤–æ–¥–æ–º */
    const dataBefore = await contract.getContractData();
    const cpBefore   = BigInt(dataBefore.commissionsPool);   // ‚Üê –ø—Ä–∏–≤–æ–¥–∏–º –∫ bigint
    expect(cpBefore).toBeGreaterThanOrEqual(toNano("0.5"));

    /* 4. –í—ã–≤–æ–¥–∏–º –∫–æ–º–∏—Å—Å–∏–∏ */
    const modBalanceBefore = await moderatorWallet.getBalance();
    await contract.sendWithdrawCommissions(moderatorWallet.getSender());

    /* 5. –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç */
    const dataAfter = await contract.getContractData();
    const cpAfter   = BigInt(dataAfter.commissionsPool);
    expect(cpAfter).toBe(toNano("0.5"));                     // –≤ –ø—É–ª–µ –æ—Å—Ç–∞–ª—Å—è —Ä–µ–∑–µ—Ä–≤

    const modBalanceAfter = await moderatorWallet.getBalance();
    const margin = toNano("0.07");        // 0.05 TON + –Ω–µ–±–æ–ª—å—à–æ–π –∑–∞–ø–∞—Å –Ω–∞ fee

    expect(
      BigInt(modBalanceAfter) - BigInt(modBalanceBefore)
    ).toBeGreaterThanOrEqual(
      cpBefore - toNano("0.5") - margin   // —É—á–ª–∏ –≤—Ö–æ–¥—è—â–∏–π value + fee
    );
});


});

/**
 * –¢–µ—Å—Ç ¬´Refund unknown funds¬ª
 * -------------------------------------------------------
 * Happy‚Äëpath –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø—É–±–ª–∏—á–Ω—ã—Ö –º–µ—Ç–æ–¥–æ–≤ –æ–±—ë—Ä—Ç–∫–∏ —É–∂–µ –ø–æ–∫—Ä—ã—Ç—ã, ‚Äî
 * –∑–¥–µ—Å—å –∏—Å–ø–æ–ª—å–∑—É–µ–º —Ç–æ—Ç –∂–µ —Å—Ç–∏–ª—å (treasury‚Äë–∫–æ—à–µ–ª—å–∫–∏ + wrapper),
 * –Ω–æ –±–µ–∑ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã—Ö ¬´—Å—ã—Ä–æ–º—è—Ç–Ω—ã—Ö¬ª —Ö–∞–∫–æ–≤ –≤ —Ä–∞–Ω—Ç–∞–π–º–µ.
 */

/**
 * –¢–µ—Å—Ç ¬´Refund unknown funds¬ª —Å —É—á—ë—Ç–æ–º –∫–æ–º–∏—Å—Å–∏–∏ –ø—Ä–∏ –ø–æ—Å—Ç—É–ø–ª–µ–Ω–∏–∏
 * -------------------------------------------------------
 * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç: –∑–∞–ª—ë—Ç–Ω—ã–π –ø–ª–∞—Ç—ë–∂ ‚Üí –∫–æ–º–∏—Å—Å–∏—è ‚Üí –≤–æ–∑–≤—Ä–∞—Ç –æ—Å—Ç–∞—Ç–∫–∞
 */

/**
 * –ü—Ä–æ–≤–µ—Ä—è–µ–º –æ–±—Ä–∞–±–æ—Ç–∫—É ¬´–∑–∞–ª—ë—Ç–Ω–æ–≥–æ¬ª –ø–ª–∞—Ç–µ–∂–∞, –≤–æ–∑–≤—Ä–∞—Ç unknown funds
 * –∏ –≤—ã–≤–æ–¥ –∫–æ–º–∏—Å—Å–∏–π –º–æ–¥–µ—Ä–∞—Ç–æ—Ä–æ–º.
 */

    describe("P2P ‚Äì refund unknown funds (correct check)", () => {
        let blockchain: Blockchain;
        let contract: SandboxContract<P2P>;
        let moderator: SandboxContract<TreasuryContract>;
    
        beforeEach(async () => {
            blockchain = await Blockchain.create();
            moderator  = await blockchain.treasury("moderator");
    
            const code = await compile("P2P");
            const cfg  = P2P.createFromConfig(moderator.address, code, 0);
    
            contract = blockchain.openContract(cfg);
            await contract.sendDeploy(moderator.getSender(), toNano("0.05"));
        });
    
        it("stores stray payment and throws on second refund", async () => {
            /* ------------------------------------------------------------------
             * 1. ¬´–ó–∞–ª—ë—Ç–Ω—ã–π¬ª –ø–ª–∞—Ç—ë–∂ –æ—Ç –ø–æ—Å—Ç–æ—Ä–æ–Ω–Ω–µ–≥–æ –∞–¥—Ä–µ—Å–∞
             * ----------------------------------------------------------------*/
            const stranger = await blockchain.treasury("stranger");
            const deposit  = toNano("1000");                 // 1000 TON
    
            const memoCell = beginCell().storeStringTail("ghost-memo").endCell();
            const body     = beginCell().storeRef(memoCell).endCell();
    
            await stranger.send({
                to:   contract.address,
                value: deposit,
                bounce: true,
                sendMode: 1,                    // pay fees separately
                body,
            });
    
            // –∫–æ–º–∏—Å—Å–∏—è 3 % –¥–æ–ª–∂–Ω–∞ –ø–æ–ø–∞—Å—Ç—å –≤ –ø—É–ª
            const commission  = deposit * 3n / 100n;          // 30 TON
            const expectedNet = deposit - commission;         // 970 TON ‚Äì –≤ unknown_funds[0]
    
            const stored = await contract.getUnknownFund(0);
            expect(stored).toBe(expectedNet);
    
            /* ------------------------------------------------------------------
             * 2. –ü–µ—Ä–≤—ã–π –≤–æ–∑–≤—Ä–∞—Ç unknown funds
             * ----------------------------------------------------------------*/
            const balBefore = await stranger.getBalance();
    
            await contract.sendRefundUnknown(
                moderator.getSender(),
                0,                                       // key
            );
    
            // –∑–∞–ø–∏—Å—å –¥–æ–ª–∂–Ω–∞ –∏—Å—á–µ–∑–Ω—É—Ç—å
            const storedAfter = await contract.getUnknownFund(0);
            expect(storedAfter).toBe(0n);
    
            // –Ω–∞ –±–∞–ª–∞–Ω—Å –ø—Ä–∏—à–ª–æ ~970 TON (‚Äë–∫–æ–º–∏—Å—Å–∏–∏ —Å–µ—Ç–∏)
            const balAfter = await stranger.getBalance();
            expect(balAfter - balBefore)
                .toBeGreaterThanOrEqual(expectedNet - toNano("0.1")); // –æ—Å—Ç–∞–≤–ª—è–µ–º –∑–∞–ø–∞—Å 0.1 TON
    
            /* ------------------------------------------------------------------
             * 3. –ü–æ–≤—Ç–æ—Ä–Ω—ã–π –≤–æ–∑–≤—Ä–∞—Ç ‚Üí –æ—à–∏–±–∫–∞ 120
             * ----------------------------------------------------------------*/
            const tx = await contract.sendRefundUnknown(
                moderator.getSender(),
                0,
            );
    
            expect(tx.transactions).toHaveTransaction({
                to:      contract.address,
                success: false,
                exitCode: 120,
            });
    
            /* ------------------------------------------------------------------
             * 4. –ú–æ–¥–µ—Ä–∞—Ç–æ—Ä –≤—ã–≤–æ–¥–∏—Ç –∫–æ–º–∏—Å—Å–∏–∏
             *    –í –ø—É–ª–µ —Å–µ–π—á–∞—Å 30 TON, –∫–æ–Ω—Ç—Ä–∞–∫—Ç –æ—Å—Ç–∞–≤–∏—Ç —Ä–µ–∑–µ—Ä–≤ 0.5 TON
             * ----------------------------------------------------------------*/
            const modBalBefore = await moderator.getBalance();
    
            // –æ–∂–∏–¥–∞–µ–º–∞—è –≤—ã–ø–ª–∞—Ç–∞ –∏–∑ –ø—É–ª–∞: 30 TON ‚àí 0.5 TON = 29.5 TON
            const expectedPayout = commission - toNano("0.5");
    
            await contract.sendWithdrawCommissions(moderator.getSender());
    
            const modBalAfter = await moderator.getBalance();
            // —É—á—Ç—ë–º 0.05 TON, –∫–æ—Ç–æ—Ä–æ–µ –º–æ–¥–µ—Ä–∞—Ç–æ—Ä –ø—Ä–∏–ª–æ–∂–∏–ª, –∏ —Å–µ—Ç–µ–≤—ã–µ fee (<0.01 TON)
            const margin = toNano("0.11");              // 0.05 value + ~0.06 –∑–∞–ø–∞—Å
    
            expect(modBalAfter - modBalBefore)
                .toBeGreaterThanOrEqual(expectedPayout - margin);
    
            // –≤ –ø—É–ª–µ –¥–æ–ª–∂–µ–Ω –æ—Å—Ç–∞—Ç—å—Å—è —Ä–µ–∑–µ—Ä–≤ 0.5 TON
            const poolAfter = (await contract.getContractData()).commissionsPool;
            expect(BigInt(poolAfter)).toBe(toNano("0.5"));
        });
    });
    /* --------------------------------------------------------------------------
 * –í—Ç–æ—Ä–æ–π —Å—Ü–µ–Ω–∞—Ä–∏–π: —Å–ª—É—á–∞–π–Ω–∞—è —Å—Ç—Ä–æ–∫–∞‚Äëmemo –∏ –º–∞–ª–µ–Ω—å–∫–∏–π –∫–æ–º–∏—Å—Å–∏–æ–Ω–Ω—ã–π –ø—É–ª
 * -------------------------------------------------------------------------*/

describe("P2P ‚Äì refund unknown funds (random memo)", () => {
    let blockchain: Blockchain;
    let moderator: SandboxContract<TreasuryContract>;
    let contract:   SandboxContract<P2P>;

    beforeEach(async () => {
        blockchain = await Blockchain.create();
        moderator  = await blockchain.treasury("moderator");

        const code = await compile("P2P");
        const cfg  = P2P.createFromConfig(moderator.address, code, 0);
        contract   = blockchain.openContract(cfg);

        await contract.sendDeploy(moderator.getSender(), toNano("0.05"));
    });

    it("handles unknown memo correctly", async () => {
        /* ------------------------------------------------------------------
         * 1. ¬´–ó–∞–ª—ë—Ç–Ω—ã–π¬ª –ø–µ—Ä–µ–≤–æ–¥ —Å random‚Äëmemo
         * ----------------------------------------------------------------*/
        const stranger   = await blockchain.treasury("stranger");
        const deposit    = toNano("1");                   // 1 TON

        const randomMemo = `unknown-memo-${Math.floor(Math.random() * 1e6)}`;
        const memoCell   = beginCell().storeStringTail(randomMemo).endCell();
        const body       = beginCell().storeRef(memoCell).endCell();

        await stranger.send({
            to:       contract.address,
            value:    deposit,
            bounce:   true,
            sendMode: 1,
            body,
        });

        const commission  = deposit * 3n / 100n;           // 0.03 TON
        const expectedNet = deposit  - commission;         // 0.97 TON

        expect(await contract.getUnknownFund(0)).toBe(expectedNet);

        /* ------------------------------------------------------------------
         * 2. –ü–µ—Ä–≤—ã–π –≤–æ–∑–≤—Ä–∞—Ç
         * ----------------------------------------------------------------*/
        const balBefore = await stranger.getBalance();

        await contract.sendRefundUnknown(moderator.getSender(), 0);

        expect(await contract.getUnknownFund(0)).toBe(0n);

        const balAfter = await stranger.getBalance();
        expect(balAfter - balBefore)
            .toBeGreaterThanOrEqual(expectedNet - toNano("0.05"));

        /* ------------------------------------------------------------------
         * 3. –ü–æ–≤—Ç–æ—Ä–Ω—ã–π –≤–æ–∑–≤—Ä–∞—Ç ‚Üí throw 120
         * ----------------------------------------------------------------*/
        const tx = await contract.sendRefundUnknown(moderator.getSender(), 0);
        expect(tx.transactions).toHaveTransaction({
            to:       contract.address,
            success:  false,
            exitCode: 120,
        });

        /* ------------------------------------------------------------------
         * 4. –ü–æ–ø—ã—Ç–∫–∞ –≤—ã–≤–µ—Å—Ç–∏ –∫–æ–º–∏—Å—Å–∏–∏, –∫–æ—Ç–æ—Ä—ã—Ö –º–µ–Ω—å—à–µ 0.5 TON
         * ----------------------------------------------------------------*/
        const modBalBefore = await moderator.getBalance();

        await contract.sendWithdrawCommissions(moderator.getSender());

        const modBalAfter = await moderator.getBalance();
        // –º–æ–¥–µ—Ä–∞—Ç–æ—Ä —Ç–æ–ª—å–∫–æ –∑–∞–ø–ª–∞—Ç–∏–ª 0.05 TON + fee, –≤—ã–ø–ª–∞—Ç—ã –Ω–µ –±—ã–ª–æ
        expect(modBalAfter).toBeLessThan(modBalBefore);

        const { commissionsPool } = await contract.getContractData();
        // –ø—É–ª –Ω–µ —Ç—Ä–æ–Ω—É—Ç, —Ç–∞–º –≤—Å—ë –µ—â—ë –Ω–∞—à–∏ 0.03 TON
        expect(BigInt(commissionsPool)).toBe(commission);
    });
});

/* –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –∫–æ–Ω—Å—Ç–∞–Ω—Ç—ã –¥–ª—è –Ω–æ–≤—ã—Ö –∫–µ–π—Å–æ–≤ */
const DEAL_AMOUNTS   = ["0.5", "0.8", "1", "1.2", "0.7"]; // TON
const MIN_CREATE_FEE = 3_000_000n;                        // 0.003 TON
const CP_RESERVE_GAS = toNano("0.5");

/*‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 1. –ú–∞—Å—Å–æ–≤–æ–µ —Å–æ–∑–¥–∞–Ω–∏–µ —Å–¥–µ–ª–æ–∫ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ*/
describe("P2P ‚Äì –¥–µ–ø–æ–∑–∏—Ç –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –º–Ω–æ–∂–µ—Å—Ç–≤–∞ —Å–¥–µ–ª–æ–∫", () => {
    let bc: Blockchain;
    let moderator: SandboxContract<TreasuryContract>;
    let seller: SandboxContract<TreasuryContract>;
    let buyer: SandboxContract<TreasuryContract>;
    let contract: SandboxContract<P2P>;

    beforeEach(async () => {
        bc        = await Blockchain.create();
        moderator = await bc.treasury("moderator");
        seller    = await bc.treasury("seller");
        buyer     = await bc.treasury("buyer");

        const code = await compile("P2P");
        contract   = bc.openContract(P2P.createFromConfig(moderator.address, code));
        await contract.sendDeploy(moderator.getSender(), toNano("0.05"));
    });

    it("commissionsPool == N √ó MIN_CREATE_FEE", async () => {
        for (let i = 0; i < DEAL_AMOUNTS.length; i++) {
            const memo = `bulk-${i}`;
            await contract.sendCreateDeal(
                moderator.getSender(),
                seller.address,
                buyer.address,
                toNano(DEAL_AMOUNTS[i]),
                memo
            );
            await contract.sendFundDeal(buyer.getSender(), memo, toNano(DEAL_AMOUNTS[i]));
        }

        const { commissionsPool } = await contract.getContractData();
        expect(BigInt(commissionsPool)).toBe(
            MIN_CREATE_FEE * BigInt(DEAL_AMOUNTS.length)
        );
    });
});

/*‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 2. –°–¥–µ–ª–∫–∞ –Ω–∞ 1 nanoTON ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ*/
describe("P2P ‚Äì —Å–¥–µ–ª–∫–∞ –Ω–∞ 1 nanoTON", () => {
    let bc: Blockchain;
    let moderator: SandboxContract<TreasuryContract>;
    let seller: SandboxContract<TreasuryContract>;
    let buyer: SandboxContract<TreasuryContract>;
    let contract: SandboxContract<P2P>;

    beforeEach(async () => {
        bc        = await Blockchain.create();
        moderator = await bc.treasury("moderator");
        seller    = await bc.treasury("seller");
        buyer     = await bc.treasury("buyer");

        const code = await compile("P2P");
        contract   = bc.openContract(P2P.createFromConfig(moderator.address, code));
        await contract.sendDeploy(moderator.getSender(), toNano("0.05"));
    });

    it("–¥–µ–ø–æ–∑–∏—Ç –ø–æ–ø–∞–ª –≤ –ø—É–ª, –∫–æ–º–∏—Å—Å–∏—è –∑–∞ —Å–¥–µ–ª–∫—É = 0", async () => {
        const memo = "nano-test";

        await contract.sendCreateDeal(
            seller.getSender(),            // –ª—é–±–æ–π –∞–¥—Ä–µ—Å
            seller.address,
            buyer.address,
            1n,                            // 1 nanoTON
            memo
        );
        await contract.sendFundDeal(buyer.getSender(), memo, toNano("0.03"));

        expect((await contract.getDealInfo(0)).funded).toBe(1);
        expect(BigInt((await contract.getContractData()).commissionsPool))
              .toBe(MIN_CREATE_FEE);
    });
});

/*‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 3. –û—à–∏–±–∫–∏ Fund / Resolve ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ*/
describe("P2P ‚Äì –æ—à–∏–±–∫–∏ Fund / Resolve", () => {
    let bc: Blockchain;
    let moderator: SandboxContract<TreasuryContract>;
    let stranger: SandboxContract<TreasuryContract>;
    let seller: SandboxContract<TreasuryContract>;
    let buyer: SandboxContract<TreasuryContract>;
    let contract: SandboxContract<P2P>;

    beforeEach(async () => {
        bc        = await Blockchain.create();
        moderator = await bc.treasury("moderator");
        stranger  = await bc.treasury("stranger");
        seller    = await bc.treasury("seller");
        buyer     = await bc.treasury("buyer");

        const code = await compile("P2P");
        contract   = bc.openContract(P2P.createFromConfig(moderator.address, code));
        await contract.sendDeploy(moderator.getSender(), toNano("0.05"));
    });

    test("FundDeal < amount ‚áí exit 132", async () => {
        const memo = "need-2-ton";
        await contract.sendCreateDeal(
            moderator.getSender(),
            seller.address,
            buyer.address,
            toNano("2"),
            memo
        );

        const tx = await contract.sendFundDeal(
            buyer.getSender(),
            memo,
            toNano("1.99")
        );

        expect(tx.transactions).toHaveTransaction({ success: false, exitCode: 132 });
    });

    test("Resolve –ø–æ –Ω–µ—Å—É—â–µ—Å—Ç–≤—É—é—â–µ–º—É memo ‚áí exit 401", async () => {
        const tx = await contract.sendResolveDealExternal(
            moderator.getSender(),
            "ghost-memo",
            true
        );

        expect(tx.transactions).toHaveTransaction({ success: false, exitCode: 401 });
    });
});

/*‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 4. –ü–æ–≤—Ç–æ—Ä–Ω—ã–π Fund –∏ —Ä–∞–Ω–Ω–∏–π Resolve ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ*/
describe("P2P ‚Äì –ø–æ–≤—Ç–æ—Ä–Ω—ã–π Fund –∏ —Ä–∞–Ω–Ω–∏–π Resolve", () => {
    let bc: Blockchain,
        moderator: SandboxContract<TreasuryContract>,
        seller: SandboxContract<TreasuryContract>,
        buyer: SandboxContract<TreasuryContract>,
        contract: SandboxContract<P2P>;

    beforeEach(async () => {
        bc        = await Blockchain.create();
        moderator = await bc.treasury("moderator");
        seller    = await bc.treasury("seller");
        buyer     = await bc.treasury("buyer");

        const code = await compile("P2P");
        contract   = bc.openContract(P2P.createFromConfig(moderator.address, code));
        await contract.sendDeploy(moderator.getSender(), toNano("0.05"));
    });

    test("–ø–æ–≤—Ç–æ—Ä–Ω—ã–π Fund ‚áí exit 131", async () => {
        const memo = "double-fund";
        await contract.sendCreateDeal(
            moderator.getSender(), seller.address, buyer.address, toNano("2"), memo
        );
        await contract.sendFundDeal(buyer.getSender(), memo, toNano("2"));

        const tx = await contract.sendFundDeal(buyer.getSender(), memo, toNano("2"));
        expect(tx.transactions).toHaveTransaction({ success: false, exitCode: 131 });
    });

    test("Resolve –¥–æ Fund ‚áí exit 111", async () => {
        const memo = "resolve-early";
        await contract.sendCreateDeal(
            moderator.getSender(), seller.address, buyer.address, toNano("1"), memo
        );

        const tx = await contract.sendResolveDealExternal(
            moderator.getSender(), memo, true
        );

        expect(tx.transactions).toHaveTransaction({ success: false, exitCode: 111 });
    });
});

/*‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 5. WithdrawCommissions –ø—Ä–∏ pool = 0 ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ*/
describe("P2P ‚Äì –ø—É—Å—Ç–æ–π –ø—É–ª –∫–æ–º–∏—Å—Å–∏–π", () => {
    let bc: Blockchain, moderator: SandboxContract<TreasuryContract>,
        contract: SandboxContract<P2P>;

    beforeEach(async () => {
        bc        = await Blockchain.create();
        moderator = await bc.treasury("moderator");
        const code = await compile("P2P");
        contract   = bc.openContract(P2P.createFromConfig(moderator.address, code));
        await contract.sendDeploy(moderator.getSender(), toNano("0.05"));
    });

    test("–≤—ã–≤–æ–¥ –Ω–µ–≤–æ–∑–º–æ–∂–µ–Ω, exit 401", async () => {
        const bal0 = await moderator.getBalance();

        const tx = await contract.sendWithdrawCommissions(moderator.getSender());
        expect(tx.transactions).toHaveTransaction({ success: false, exitCode: 401 });

                const bal1 = await moderator.getBalance();
                const maxGasLoss = toNano("0.02");   // ~0.02 TON ‚Äî —â–∞–¥—è—â–∏–π –ø–æ—Ç–æ–ª–æ–∫ fee
                expect(bal0 - bal1).toBeLessThanOrEqual(maxGasLoss);
        
    });
});

/*‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 6. –í—ã–≤–æ–¥ –∫–æ–º–∏—Å—Å–∏–π (reserve 0.5 TON) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ*/
describe("P2P ‚Äì –≤—ã–≤–æ–¥ –∫–æ–º–∏—Å—Å–∏–π (reserve 0.5 TON)", () => {
    let bc: Blockchain,
        moderator: SandboxContract<TreasuryContract>,
        seller: SandboxContract<TreasuryContract>,
        buyer: SandboxContract<TreasuryContract>,
        contract: SandboxContract<P2P>;

    beforeEach(async () => {
        bc        = await Blockchain.create();
        moderator = await bc.treasury("moderator");
        seller    = await bc.treasury("seller");
        buyer     = await bc.treasury("buyer", { balance: toNano("1000000") });

        const code = await compile("P2P");
        contract   = bc.openContract(P2P.createFromConfig(moderator.address, code));
        await contract.sendDeploy(moderator.getSender(), toNano("0.05"));
    });

    it("–ø–æ—Å–ª–µ withdraw –≤ –ø—É–ª–µ –æ—Å—Ç–∞—ë—Ç—Å—è 0.5 TON", async () => {
        const DEAL = toNano("2000");
        for (let i = 0; i < 10; i++) {
            const memo = `d-${i}`;
            await contract.sendCreateDeal(
                moderator.getSender(), seller.address, buyer.address, DEAL, memo
            );
            await contract.sendFundDeal(buyer.getSender(), memo, DEAL);
            await contract.sendResolveDealExternal(
                moderator.getSender(), memo, true
            );
        }

        const before = BigInt((await contract.getContractData()).commissionsPool);
        const bal0   = await moderator.getBalance();

        await contract.sendWithdrawCommissions(moderator.getSender());

        const after = BigInt((await contract.getContractData()).commissionsPool);
        expect(after).toBe(CP_RESERVE_GAS);

        const margin = toNano("0.07");
        expect(BigInt(await moderator.getBalance()) - BigInt(bal0))
            .toBeGreaterThanOrEqual(before - CP_RESERVE_GAS - margin);
    });
});
/*‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 7. Unknown Funds > UF_MAX_RECORDS  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ*/
describe("P2P ‚Äì UF_MAX_RECORDS overflow", () => {
    let bc: Blockchain,
        moderator: SandboxContract<TreasuryContract>,
        spammer:   SandboxContract<TreasuryContract>,
        contract:  SandboxContract<P2P>;

    // ‚ù∂ –ü–æ–¥–Ω–∏–º–µ–º chain –∏ –¥–µ–ø–ª–æ–∏–º –∫–æ–Ω—Ç—Ä–∞–∫—Ç
    beforeEach(async () => {
        bc        = await Blockchain.create();
        moderator = await bc.treasury("moderator");
        spammer   = await bc.treasury("spammer", { balance: toNano("4000") });

        const code = await compile("P2P");
        contract   = bc.openContract(P2P.createFromConfig(moderator.address, code));
        await contract.sendDeploy(moderator.getSender(), toNano("0.05"));
    });

    /** UF_MAX_RECORDS = 10 000 ‚áí 10 001-–π –ø–ª–∞—Ç—ë–∂ –¥–æ–ª–∂–µ–Ω —É–ø–∞—Å—Ç—å —Å exit 152 */
    it("> UF_MAX_RECORDS ‚áí exit 152", async () => {
        const UF_MAX = 10_000;                 // —Å–º. –∫–æ–Ω—Å—Ç–∞–Ω—Ç—É –≤ P2P.fc
        const deposit = toNano("0.2");         // 0.2 TON: –º–∞–ª–µ–Ω—å–∫–∏–π, –Ω–æ >0.1 TON

        // ‚ù∑ ¬´–ó–∞–±–∏–≤–∞–µ–º¬ª unknown_funds –¥–æ –ª–∏–º–∏—Ç–∞
        for (let i = 0; i < UF_MAX; i++) {
            await spammer.send({
                to:       contract.address,
                value:    deposit,
                bounce:   true,
                sendMode: 1,                   // pay fees separately
            });
        }

        // ‚ù∏ 10 001-–π –ø–ª–∞—Ç—ë–∂ ‚Äì –∂–¥—ë–º throw(152)
        const trace = await spammer.send({
            to:       contract.address,
            value:    deposit,
            bounce:   true,
            sendMode: 1,
        });

        expect(trace.transactions).toHaveTransaction({
            to:       contract.address,
            success:  false,
            exitCode: 152,                    // UF_MAX_RECORDS overflow
        });

        // ‚ùπ –£–±–µ–¥–∏–º—Å—è, —á—Ç–æ —Å—á—ë—Ç—á–∏–∫ –±–æ–ª—å—à–µ –Ω–µ —Ä–∞—Å—Ç—ë—Ç
        const lastKey = await contract.getUnknownFund(UF_MAX /* 10 000 */);
        expect(lastKey).toBe(0n);             // –∑–∞–ø–∏—Å–∏ –Ω–µ—Ç
    }, 300_000);  // ‚è± —É–≤–µ–ª–∏—á–∏–º —Ç–∞–π–º–∞—É—Ç ‚Äì 10 001 tx ‚âà 3-4 —Å
});


describe('P2P ‚Äì Micro-gas –∫–æ–Ω—Ç—Ä–æ–ª—å', () => {
    let bc: Blockchain,
        moderator: SandboxContract<TreasuryContract>,
        sender:     SandboxContract<TreasuryContract>,
        contract:   SandboxContract<P2P>;

    /* ‚îÄ‚îÄ bootstrap ‚îÄ‚îÄ */
    beforeEach(async () => {
        bc = await Blockchain.create();
        bc.verbosity = {
            blockchainLogs: true,
            vmLogs:  'vm_logs_full',
            debugLogs: true,
            print:  false,
        };

        moderator = await bc.treasury('moderator');
        sender    = await bc.treasury('gas-tester', { balance: toNano('10') });

        const code = await compile('P2P');
        contract   = bc.openContract(P2P.createFromConfig(moderator.address, code));
        await contract.sendDeploy(moderator.getSender(), toNano('0.05'));
    });

    it('stray-payment gas usage ‚â§ 3500', async () => {
        /* 1. ¬´–ó–∞–ª—ë—Ç–Ω—ã–π¬ª –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–π –ø–µ—Ä–µ–≤–æ–¥ –±–µ–∑ body */
        const value = toNano('0.2');            // > 0.1 TON min
        const trace = await sender.send({
            to:       contract.address,
            value,
            bounce:   true,
            sendMode: 1,                       // pay fees separately
        });

        /* 2. –ò—â–µ–º —É—Å–ø–µ—à–Ω—É—é —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é –∫–æ–Ω—Ç—Ä–∞–∫—Ç–∞ */
        const contractAddr = contract.address.toString();    // –∫–∞–Ω–æ–Ω–∏—á–µ—Å–∫–∏–π –≤–∏–¥
        const contractTx = trace.transactions.find((tx: any) => {
            const addrString: string | undefined =
                // —Å—Ç–∞—Ä—ã–π —Ñ–æ—Ä–º–∞—Ç: —Å—Ç—Ä–æ–∫–∞ –≤ –ø–æ–ª–µ address
                (typeof tx.address === 'string' ? tx.address : undefined) ||
                // –µ—Å–ª–∏ address = Address
                (tx.address?.toString?.())                     ||
                // generic-tx  ‚îÄ dest –≤ inbound-message
                (tx.inMessage?.info?.dest?.toString?.())       ||
                // generic-tx  ‚îÄ –ø–æ–ª–µ description.on
                (tx.description?.type === 'generic'
                    ? tx.description.on?.toString?.()
                    : undefined);

            return addrString === contractAddr && tx.success === true;
        });

        if (!contractTx) {
            throw new Error('Tx of contract not found in trace');
        }

        /* 3. –ò–∑–≤–ª–µ–∫–∞–µ–º gas (SDK ‚â•0.25 ‚Üí totalGasUsed,  <0.25 ‚Üí gasUsed) */
        const gasUsed: number =
              (contractTx as any).totalGasUsed   // –Ω–æ–≤—ã–µ –≤–µ—Ä—Å–∏–∏ SDK
           ?? (contractTx as any).gasUsed        // —Å—Ç–∞—Ä—ã–µ –≤–µ—Ä—Å–∏–∏
           ?? 0;

        process.stdout.write(`üí® gasUsed = ${gasUsed}\n`);
        expect(gasUsed).toBeLessThanOrEqual(3500);
    });
});
